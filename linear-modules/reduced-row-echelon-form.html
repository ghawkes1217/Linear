<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Linear Algebra: Reduced Row Echelon Form</title>

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
    }
  </script>

  <!-- The following adds MathJax to render LaTeX notation -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>

  <script type="text/javascript" src="../site-scripts.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <style>
    /* This floats elements into columns */
    .float {
      display: flex;
      justify-content: space-around;
      align-items: center;}

    /* This defines the styles for the question header */
    .questionHeader {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;}

    .questionBox {
      width: 600px;
      height: 170px;}

    .questionArea {
      width: 620px;
      height: 50px;}

    #response {
      height: 20px;}

    .itemPrompt {
      width: 225px;
      height: 200px;
      position: relative;
      top: 20px;}

    /* This defines the styles for setting elementary matrix options
       and for the display of matrix multiplication */
    .operations-dropdown {
      height: 20px;
      border-radius: 5px;}

    .displayArea {
      width: 700px;
      height: 175px;}

    .matrixOptions {
      /*border: 2px dashed black;*/
      width: 250px;}

    /* This defines the styles for the matrix header */
    .matrixHeader {
      width: 900px;
      height: 200px}

    .entry { 
      width: 40px;
      height: 15px;
      border-radius: 5px;}

    .buttonAreaOne {
      position: relative; 
      top: 20px;}

    .buttonAreaTwo {
      position: relative; 
      top: 30px;}

    /* This wraps questionHeader, matrixOptions and matrixHeader elements within a single container*/
    .elementWrapper{
      display: flex;
      justify-content: space-between;
      align-items: center;}

    /* This styles the text for completed questions */
    .greytext {
      color: grey;}

    /* These are additional boxes for scaffolding */
    .box { 
      width: 200px;
      /*border: black 2px dotted;*/
      height: 100px;}

    .smallbox { 
      width: 50px;
      /*border: black 2px dotted;*/
      height: 15px;}

    .largebox { 
      width: 500px;
      /*border: black 2px dotted;*/
      height: 100px;}

    /* This hides irrelevant elements */
    .hidden {
      display: none;}

    ol {
      counter-reset: x;
      list-style-type: none;
    }
    ol li::before {
      counter-increment: x;
      content: "(" counter(x) ")";
    }
  </style>
</head>

<body>
  <div style="position: absolute;">
    <a href="../linear-lab.html" class="backto">&#8592 Back to Linear Lab</a>
  </div>
  <h2><center>Module 9: Reduced Row Echelon Form</center></h2>
  <div id="introduction">
    <p>
      Ever wondered if you could determine whether or not the inverse of a large square matrix, say $100\times 100$, exists? You can actually do this in general, using a reduced row echelon form for matrices. 
    </p>

    <p>
      What exactly is a reduced row echelon form for a matrix? A matrix is said to be in a reduced row echelon form if it 
      meets all of the following conditions:
      <ol>
        <li> Every nonzero row is lead by a 1 (there may be extra zeros before); this entry is also known as a <b><em>pivot</em></b>.</li>
        <li> All entries above and below a pivot must equal 0.</li>
        <li> Pivots would progress from left to right as one goes down the rows.</li> 
        <li> All rows of zeros (if any) appear at the bottom of the matrix.</li>
      </ol>
    </p>

    <p>
      These conditions would force a reduced row echelon matrix to take a particular shape. Here is a generic example with several pivots, each shown in bolded red:
      $$\begin{bmatrix}
        0 & \ldots & 0 & \mathbf{\color{red}{1}} & * & \ldots & * & 0 & * & \ldots & * & 0 & * & \ldots & *\\
        0 & \ldots & 0 & 0 & 0 & \ldots & 0 & \mathbf{\color{red}{1}} & * & \ldots & * & 0 & * & \ldots & *\\
        0 & \ldots & 0 & 0 & 0 & \ldots & 0 & 0 & 0 & \ldots & 0 & \mathbf{\color{red}{1}} & * & \ldots & *\\
        0 & \ldots & 0 & 0 & 0 & \ldots & 0 & 0 & 0 & \ldots & 0 & 0 & 0 & \ldots & 0 \\
        0 & \ldots & 0 & 0 & 0 & \ldots & 0 & 0 & 0 & \ldots & 0 & 0 & 0 & \ldots & 0
      \end{bmatrix}.$$
      Here, each entry with the symbol * denotes that any real number is possible in that entry. Moreover, it is entirely possible for some matrices in this form that any combination of the following can occur:
      <ul>
        <li> that there are no columns before the first pivot, </li> 
        <li> that there are no columns separating two pivots at consecutive rows, </li>
        <li> that there are no columns after the last pivot, </li>
        <li> that there are no rows of zeros at the bottom. </li>
      </ul>
    </p>

    <p>
      How could we obtain a reduced row echelon form (abbreviated as r.r.e.f) for a matrix? Simply put, we would need to perform 
      row operations on the matrix until we reach a form as defined above. In order to achieve this systematically, we may perform 
      the following procedure for every row $R$ in the matrix, beginning from the top and ending at the bottom.
      <ol>
        <li> Whenever necessary, swap zero rows with some other rows so that these zero rows appear at the very bottom of the matrix.</li>
        <li> Identify the locations of the leading nonzero entry for row $R$ and those of all the rows below it. If the leading nonzero entry of $R$ is not the leftmost one, swap it with another row whose leading nonzero entry is the leftmost. </li>
        <li> Suppose $a$ is the value of this leading entry for row $R$. Scale row $R$ by $1/a$ to make it a pivot. </li>
        <li> Eliminate all other entries in the same column as the pivot for row $R$. Specifically, if another row $R'$ has a nonzero entry $b$ in the same column as the pivot, add $-b$ times row $R$ to row $R'$.</li>
        <li> Repeat steps (1) through (4) with the row directly below $R$ until we reach the bottommost row. Should all rows below $R$ happen to be zero rows, stop immediately and return the matrix as being in a r.r.e.f.</li>
      </ol>

      It can be shown more rigorously that a r.r.e.f. for a matrix is unique and does not depend on the row operations involved to 
      attain it, so we may actually speak of <em>the</em> r.r.e.f. for a matrix. 
    </p>

    <p>
      To illustrate the above procedure with an example, let us begin with the matrix 
      $$A = \begin{bmatrix} 
      0 & 1 & -1 & 1 & 1 & 0\\ 
      2 & 2 & 0 & -2 & 0 & 2\\
      3 & -3 & 3 & 0 & -3 & 0
      \end{bmatrix}$$

      The steps taken according to the procedure outlined above are shown below:
      $$\begin{aligned}
      \begin{bmatrix} 
      0 & 1 & -1 & 1 & 1 & 0\\ 
      2 & 2 & 0 & -2 & 0 & 2\\
      3 & -3 & 3 & 0 & -3 & 0
      \end{bmatrix} && \xrightarrow{R_1 \leftrightarrow R_2} &&
      \begin{bmatrix} 
      2 & 2 & 0 & -2 & 0 & 2\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      3 & -3 & 3 & 0 & -3 & 0
      \end{bmatrix} && \xrightarrow{1/2\; R_2} &&
      \begin{bmatrix} 
      1 & 1 & 0 & -1 & 0 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      3 & -3 & 3 & 0 & -3 & 0
      \end{bmatrix}\\
      \begin{bmatrix} 
      1 & 1 & 0 & -1 & 0 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      3 & -3 & 3 & 0 & -3 & 0
      \end{bmatrix} && \xrightarrow{-3 R_1 + R_3} && 
      \begin{bmatrix} 
      1 & 1 & 0 & -1 & 0 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      0 & -6 & 3 & 3 & -3 & -3
      \end{bmatrix} && \xrightarrow{- R_2 + R_1} && 
      \begin{bmatrix} 
      1 & 0 & 1 & -2 & -1 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      0 & -6 & 3 & 3 & -3 & -3
      \end{bmatrix}\\
      \begin{bmatrix} 
      1 & 0 & 1 & -2 & -1 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      0 & -6 & 3 & 3 & -3 & -3
      \end{bmatrix} && \xrightarrow{6 R_2 + R_3} && 
      \begin{bmatrix} 
      1 & 0 & 1 & -2 & -1 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      0 & 0 & -3 & 9 & 3 & -3
      \end{bmatrix} && \xrightarrow{-1/3\; R_3} && 
      \begin{bmatrix} 
      1 & 0 & 1 & -2 & -1 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      0 & 0 & 1 & -3 & -1 & 1
      \end{bmatrix}\\
      \begin{bmatrix} 
      1 & 0 & 1 & -2 & -1 & 1\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      0 & 0 & 1 & -3 & -1 & 1
      \end{bmatrix} && \xrightarrow{-R_3 + R_1} && 
      \begin{bmatrix} 
      1 & 0 & 0 & 1 & 0 & 0\\
      0 & 1 & -1 & 1 & 1 & 0\\ 
      0 & 0 & 1 & -3 & -1 & 1
      \end{bmatrix} && \xrightarrow{R_3 + R_2} && 
      \begin{bmatrix} 
      1 & 0 & 0 & 1 & 0 & 0\\
      0 & 1 & 0 & -2 & 0 & 1\\ 
      0 & 0 & 1 & -3 & -1 & 1
      \end{bmatrix}.
      \end{aligned}$$

      Thus, the r.r.e.f. for $A$ is the matrix $$B = \begin{bmatrix} 1 & 0 & 0 & 1 & 0 & 0\\ 0 & 1 & 0 & -2 & 0 & 1\\ 0 & 0 & 1 & -3 & -1 & 1 \end{bmatrix}.$$
    </p>

    <p>
      Now, we could use the r.r.e.f. to determine whether or not a square matrix has an inverse.
      Consider the matrix $A = \begin{bmatrix} 1 & 1 & 0 \\ 0 & -2 & 0 \\ 0 & 3 & -3 \end{bmatrix}$. 
      Firstly, we produce a block matrix of the form $M = [A|I]$, where $I$ is the identity matrix with the same dimensions as $A$.
      In our example, $M$ would look like
      
      $$M= \left[\begin{array}{ccc|ccc}
      1 & 1 & 0 & 1 & 0 & 0 \\
      0 & -2 & 0 & 0 & 1 & 0 \\
      0 & 3 & -3 & 0 & 0 & 1 \\
      \end{array}\right].$$
    </p>

    <p>
      Next, we apply row operations until we obtain the r.r.e.f. for $M$. In our example, we have
      
      $$\begin{aligned}
      \left[\begin{array}{ccc|ccc}
      1 & 1 & 0 & 1 & 0 & 0 \\
      0 & -2 & 0 & 0 & 1 & 0 \\
      0 & 3 & -3 & 0 & 0 & 1 \\
      \end{array}\right] && \xrightarrow{-1/2\; R_2} && 
      \left[\begin{array}{ccc|ccc}
      1 & 1 & 0 & 1 & 0 & 0 \\
      0 & 1 & 0 & 0 & -1/2 & 0 \\
      0 & 3 & -3 & 0 & 0 & 1 \\
      \end{array}\right]  && \xrightarrow{-R_2+R_1} && 
      \left[\begin{array}{ccc|ccc}
      1 & 0 & 0 & 1 & 1/2 & 0 \\
      0 & 1 & 0 & 0 & -1/2 & 0 \\
      0 & 3 & -3 & 0 & 0 & 1 \\
      \end{array}\right]\\
      \left[\begin{array}{ccc|ccc}
      1 & 0 & 0 & 1 & 1/2 & 0 \\
      0 & 1 & 0 & 0 & -1/2 & 0 \\
      0 & 3 & -3 & 0 & 0 & 1 \\
      \end{array}\right] && \xrightarrow{-3R_2+R_3} && 
      \left[\begin{array}{ccc|ccc}
      1 & 0 & 0 & 1 & 1/2 & 0 \\
      0 & 1 & 0 & 0 & -1/2 & 0 \\
      0 & 0 & -3 & 0 & 3/2 & 1 \\
      \end{array}\right]  && \xrightarrow{-1/3\; R_3} && 
      \left[\begin{array}{ccc|ccc}
      1 & 0 & 0 & 1 & 1/2 & 0 \\
      0 & 1 & 0 & 0 & -1/2 & 0 \\
      0 & 0 & 1 & 0 & -1/2 & -1/3 \\
      \end{array}\right]
      \end{aligned}$$

      We see that the $3\times 3$ matrix on the left is the identity matrix $I$, so we may read off the inverse of $A$ as 
      the $3\times 3$ matrix on the right, that is, 
      $$A^{-1} = \begin{bmatrix} 1 & 1/2 & 0 \\ 0 & -1/2 & 0 \\ 0 & -1/2 & -1/3 \end{bmatrix}.$$
    </p>

    <p>
      The procedure above fails if the matrix that we started with has no inverse. Take for instance the matrix 
      $$B = \begin{bmatrix} 1 & 0 & 1 \\ 2 & 1 & 0 \\ 0 & 1 & -2 \end{bmatrix}.$$
      Performing row operations on the block matrix $M'=[B|I]$, we obtain the following:
      
      $$\begin{aligned}
      \left[\begin{array}{ccc|ccc}
      1 & 0 & 1 & 1 & 0 & 0 \\
      2 & 1 & 0 & 0 & 1 & 0 \\
      0 & 1 & -2 & 0 & 0 & 1 \\
      \end{array}\right] && \xrightarrow{-2R_1+R_2} && 
      \left[\begin{array}{ccc|ccc}
      1 & 0 & 1 & 1 & 0 & 0 \\
      0 & 1 & -2 & -2 & 1 & 0 \\
      0 & 1 & -2 & 0 & 0 & 1 \\
      \end{array}\right] && \xrightarrow{-R_2+R_3} && 
      \left[\begin{array}{ccc|ccc}
      1 & 0 & 1 & 1 & 0 & 0 \\
      0 & 2 & -2 & -2 & 1 & 0 \\
      0 & 0 & 0 & 2 & -1 & 1 \\
      \end{array}\right].
      \end{aligned}$$

      Looking at the last matrix of the row, since the left part has a row of zeros as we find the r.r.e.f. for $M'$,
      we end the procedure and conclude that $B$ has no inverse.
    </p>

    <p>
      We may also use the r.r.e.f. to determine whether or not a variable in a system of linear equations takes on a specific value. For example, consider the following system of linear equations in variables $v,w,x,y,z$:
      $$\begin{aligned}
       2v   -6x-4y &= 14,\\
      -3v-2w+9x+6y &= -33,\\
                 y &= -1.
      \end{aligned}$$
      Using variables $v,w,x,y,z$ in that order, we represent this system as an augmented matrix 
      $A=\left[\begin{array}{ccccc|c}
      2 & 0 & -6 & -4 & 0 & 14\\
      -3 & -2 & 9 & 6 & 0 & -33\\
      0 & 0 & 0 & 1 & 0 & -1
      \end{array}\right]$.

      $$\begin{aligned}
      \left[\begin{array}{ccccc|c}
      2 & 0 & -6 & -4 & 0 & 14\\
      -3 & -2 & 9 & 6 & 0 & -33\\
      0 & 0 & 0 & 1 & 0 & -1
      \end{array}\right] && \xrightarrow{1/2\; R_1} && 
      \left[\begin{array}{ccccc|c}
      1 & 0 & -3 & -2 & 0 & 7\\
      -3 & -2 & 9 & 6 & 0 & -33\\
      0 & 0 & 0 & 1 & 0 & -1
      \end{array}\right] && \xrightarrow{3\; R_1 + R_2} && 
      \left[\begin{array}{ccccc|c}
      1 & 0 & -3 & -2 & 0 & 7\\
      0 & -2 & 0 & 0 & 0 & -12\\
      0 & 0 & 0 & 1 & 0 & -1
      \end{array}\right]\\
      \left[\begin{array}{ccccc|c}
      1 & 0 & -3 & -2 & 0 & 7\\
      0 & -2 & 0 & 0 & 0 & -12\\
      0 & 0 & 0 & 1 & 0 & -1
      \end{array}\right] && \xrightarrow{-1/2\; R_2} && 
      \left[\begin{array}{ccccc|c}
      1 & 0 & -3 & -2 & 0 & 7\\
      0 & 1 & 0 & 0 & 0 & 6\\
      0 & 0 & 0 & 1 & 0 & -1
      \end{array}\right] && \xrightarrow{2R_3+R_1} && 
      \left[\begin{array}{ccccc|c}
      1 & 0 & -3 & 0 & 0 & 5\\
      0 & 1 & 0 & 0 & 0 & 6\\
      0 & 0 & 0 & 1 & 0 & -1
      \end{array}\right]\\
      \end{aligned}$$

      Now that we have the reduced row echelon form for $A$, we conclude that the value of $w$ is fixed (in fact, $w=6$). 
      On the other hand, from the same system of equations, as we may see that $v=3x+5$ and that $x$ can take on any real value, thus, $v$ can take on any real value. 
      Furthermore, there are no restrictions on the value of $z$, so that $z$ can take on any real value too. 
    </p>
  </div>

  <div id="instructions">
    <p>
      For this module, we will begin with finding the reduced row echelon form (r.r.e.f.) for matrices. 
      Next we use the r.r.e.f. to perform the following tasks:
      <ul>
        <li> Determine whether or not a $3\times 3$ matrix has an inverse, and if so, find its inverse.</li>
        <li> Determine whether or not a variable in a system of equations can take on any real value.</li>
      </ul>

      For Questions 4 to 8, you may click on 'No Inverse' if there is no inverse matrix as an answer. For Questions 9 to 12, you may click on 'Any Real Value' if instead the variable in question takes on any real value.      
    </p>

    <p>
      You may specify the row operation type under the 'Elementary Row Operation' area. Clicking on 'Reset' will reset matrix 
      $A$ to the page default for each question. After performing a row operation on matrix $A$, clicking 'Preview' would show the 
      result as matrix $B$, also summarized in display within 'Performed Row Operation' area. On the other hand, clicking 'Commit' 
      would copy entries of $B$ into $A$ and stores the row operation into memory. You may preview another row operation without 
      committing if you change your mind and decide to explore other possibilities. Should you decide to rollback the most recent 
      committed row operation, click on 'Undo' to do that.
    </p>
    
    <p>
      You may freely edit the entries of matrix $A$ and use the 'Elementary Row Operation' section as a computational sandbox. Bear in mind that once you decide to alter the entries of $A$ to be different from the previewed matrix $B$, all previous row operations will be forgotten. Entries for all text input are allowed to be rational numbers of the form $a/b$, where $a$ is an integer and $b$ is a nonzero integer.
    </p>
  </div>

  <div class="elementWrapper">
    <div>
      <div class="questionHeader">
        <div class="questionBox">
          <h3>Current question:</h3>
          <div class="questionArea">
            <p id="questionToDisplay">Click 'Start' whenever you are ready. Good luck!</p>
          </div>

          <button onclick ="gradeSubmission('matrix')" id="submitButton">Start</button>
          <button onclick="previousPage()">Previous</button>
          <button onclick="nextPage()">Next</button>
          <!--<button onclick="automaticSucceed()">Succeed Automatically</button>-->
          
          <div id="response">
          </div>
          
          <div class="popup" onclick="pop()"><u>Question Statistics</u>
            <div class="popuptext" id="myPopup">
              <h3 id="selected" style="text-align:center;">No Question Selected</h3>
              <table>
                <tr>
                  <td>Users Who Have Attempted This Question</td>
                  <td id="users">0</td>
                </tr>
                <tr>
                  <td>Percentage of Users With a Correct Response</td>
                  <td id="eventual">0</td>
                </tr>
                <tr>
                  <td>Average Number of Attempts per User</td>
                  <td id="attempts">0</td>
                </tr>
                <tr>
                  <td>Percentage of Attempts that are Correct</td>
                  <td id="overall">0</td>
                </tr>
              </table>
            </div>
          </div>
        </div>

        <div id="itemPrompt" class="itemPrompt">
        </div>
      </div>

      <div class="float">
        <div class="matrixOptions">
          <h3>Elementary row operation</h3>
          Operation type:
          <select onchange="disableParameters()" id="operationType" name="operationType" class="operations-dropdown">
            <option value="null"> </option>
            <option value="swap">Swap Rows</option>
            <option value="scale">Scale Row</option>
            <option value="add">Add Row</option>
          </select><br>
            Row \(i=\)
          <select id="row_i" name="row_i" class="operations-dropdown">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select><br>
            Row \(j=\)
          <select id="row_j" name="row_j" class="operations-dropdown">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select><br>
            Scalar \(c=\)
          <input type="text" id="scalar" name="scalar" class="entry" value=1><br><br>

          <button onclick="resetSettings()" id="reset"> Reset </button>
        </div>

        <div class="displayArea">
          <h3 class="hidden"><center>Performed Row Operation</center></h3>
          <div class="hidden" id="rowOperation">
          </div>
        </div>
      </div>

      <div class="matrixHeader float">
        <div class="augmentedMatrixOne">
          <h3>Matrix $A$</h3>
          <!--Row 1-->
          <input type="text" id="a11" class="entry" value=1>
          <input type="text" id="a12" class="entry" value=0>
          <input type="text" id="a13" class="entry" value=0>
          <input type="text" id="a14" class="entry" value=1>
          <input type="text" id="a15" class="entry" value=1>
          <input type="text" id="a16" class="entry" value=0><br><br>
          <!--Row 2-->
          <input type="text" id="a21" class="entry" value=0>
          <input type="text" id="a22" class="entry" value=1>
          <input type="text" id="a23" class="entry" value=0>
          <input type="text" id="a24" class="entry" value=2>
          <input type="text" id="a25" class="entry" value=0>
          <input type="text" id="a26" class="entry" value=2><br><br>
          <!--Row 3-->
          <input type="text" id="a31" class="entry" value=0>
          <input type="text" id="a32" class="entry" value=0>
          <input type="text" id="a33" class="entry" value=1>
          <input type="text" id="a34" class="entry" value=0>
          <input type="text" id="a35" class="entry" value=3>
          <input type="text" id="a36" class="entry" value=3><br><br>
        </div>

        <div class="buttonAreaOne">
          <button class="buttons" onclick="previewRowOperation()"> Preview </button>
          <div class="smallbox">
          </div>
          <button class="buttons" onclick="commitRowOperation()"> Commit </button>
          <div class="smallbox">
          </div>
          <button class="buttons" onclick="undoRowOperation()"> Undo </button>
        </div>

        <div class="augmentedMatrixTwo">
          <h3>Matrix $B$</h3>
          <!--Row 1-->
          <input type="text" id="b11" class="entry" value=1 disabled>
          <input type="text" id="b12" class="entry" value=0 disabled>
          <input type="text" id="b13" class="entry" value=0 disabled>
          <input type="text" id="b14" class="entry" value=1 disabled>
          <input type="text" id="b15" class="entry" value=1 disabled>
          <input type="text" id="b16" class="entry" value=0 disabled><br><br>
          <!--Row 2-->
          <input type="text" id="b21" class="entry" value=0 disabled>
          <input type="text" id="b22" class="entry" value=1 disabled>
          <input type="text" id="b23" class="entry" value=0 disabled>
          <input type="text" id="b24" class="entry" value=2 disabled>
          <input type="text" id="b25" class="entry" value=0 disabled>
          <input type="text" id="b26" class="entry" value=2 disabled><br><br>
          <!--Row 3-->
          <input type="text" id="b31" class="entry" value=0 disabled>
          <input type="text" id="b32" class="entry" value=0 disabled>
          <input type="text" id="b33" class="entry" value=1 disabled>
          <input type="text" id="b34" class="entry" value=0 disabled>
          <input type="text" id="b35" class="entry" value=3 disabled>
          <input type="text" id="b36" class="entry" value=3 disabled><br><br>
        </div>

        <div class="buttonAreaTwo">
          <button id="alternateAnswer" class="buttons hidden" onclick="gradeSubmission('alternate')">No Inverse</button>
          <p id="variable" class="hidden"> Value of $x$: <p>
          <input type="text" id="value" class="entry hidden">
        </div>
      </div>
    </div>

    <div id="score"></div>
  </div>

  <div id="completed">
    <h2>Completed questions:</h2>
  </div>

  <script>
    /////////////////////////////////
    // Classes of Response Objects //
    /////////////////////////////////

    /* This script handles rational numbers - both input and output. 
       Also, it defines methods for rational-valued matrices. 
    */

    // Returns the gcd of two integers
    function gcd(a, b){
      if (a==0 && b==0){
        alert("Both integers cannot be both zero.")
        return }
      if (a==0 && b>0){
        return b}
      if (b == 0){
        return a}
      if (b < 0){
        return gcd(a, -b)}
      if (a < 0){
        return gcd(-a, b)}
      return gcd(b, a%b)}

    // Defines a class of rational numbers
    class RationalNumber{
      constructor(a, b){
        if (b < 0){
          a = -a
          b = -b}
        let d = gcd(a,b)
        this.numerator = a/d
        this.denominator = b/d}

      toString(){
        if (this.denominator==1){
          return String(this.numerator)}
        return String(this.numerator)+"/"+String(this.denominator)}

      equals(that){
        return that instanceof RationalNumber && 
               this.numerator == that.numerator && 
               this.denominator == that.denominator
      }

      doesNotEqual(that){
        return !this.equals(that)}

      greaterThan(that){
        return this.numerator*that.denominator > this.denominator*that.numerator}

      greaterThanOrEquals(that){
        return this.numerator*that.denominator >= this.denominator*that.numerator}

      lessThan(that){
        return !this.greaterOrEquals(that)}

      lessThanOrEquals(that){
        return !this.greaterThan(that)}

      add(that){
        let m = this.numerator*that.denominator + this.denominator*that.numerator
        let n = this.denominator*that.denominator
        return new RationalNumber(m, n)}

      negate(){
        return new RationalNumber(-this.numerator, this.denominator)}

      subtract(that){
        return this.add(that.negate())}

      multiply(that){
        let m = this.numerator*that.numerator
        let n = this.denominator*that.denominator
        return new RationalNumber(m, n)}

      invert(){
        if (this.numerator==0){
          alert("One does not simply divide by zero.")}
        return new RationalNumber(this.denominator, this.numerator)}

      divide(that){
        return this.multiply(that.invert())}
    }

    function parseRational(input){
      // if input is already an instance of a rational number, do nothing
      if (input instanceof RationalNumber){
        return input}

      // if input is an integer, return is as a rational number
      if (!isNaN(input) && parseInt(input)==input){
        return new RationalNumber(input, 1)}

      n = input.length
      let numberExist = [false, false]
      let index = -1
      for (let i=0; i<n; i++){
        if (input[i] == '-'){
          if (i!=index+1 || i==n-1){
            alert("This is not a rational number.")
            return } } 
        else if (input[i] == '/'){
          if (i==0 || i==n-1 || index>0){
            alert("This is not a rational number.")
            return }
          index = i}
        else if (isNaN(input[i])){
          alert("This is not a rational number.")
          return } 
        else {
          if (!numberExist[0] && index==-1){
            numberExist[0] = true} 
          else if (!numberExist[1] && index > 0){
              numberExist[1] = true} }
      }

      if(index==-1){
        if (!numberExist[0]){
          alert("This is not a rational number.")
          return }
        let a = parseInt(input)
        return new RationalNumber(a, 1)}

      if (!numberExist[0] || !numberExist[1]){
        alert("This is not a rational number.")
        return }
      let a = parseInt(input.slice(0, index))
      let b = parseInt(input.slice(index+1, n))
      return new RationalNumber(a, b)
    }

    // Defines a class of rational-valued matrices
    class RationalMatrix extends Array{
      constructor(M){
        for (let i=1; i<M.length; i++){
          if (M[i].length != M[0].length){
            alert("Given array must be rectangular.")
            throw new Error("Given array must be rectangular.")
          }
        }

        let matrixM = []
        for (let i=0; i<M.length; i++){
          let row = []
          for (let j=0; j<M[0].length; j++){
            let entry = parseRational(M[i][j])
            if (entry == undefined){
              alert("Entry is not a rational number.")
              throw new Error("Entry is not a rational number.")
            }
            row.push(entry)
          }
          matrixM.push(row)
        }
        super(...matrixM)
        this.rowDim = matrixM.length
        this.colDim = matrixM[0].length
        }

      toString(){
        let string = "["
        for (let i=0; i<this.length; i++){
          string += "["
          for (let j=0; j<this[0].length; j++){
            string += this[i][j].toString()
            if (j < this[i].length-1){
              string += ", "
            }
          }
          string += "]"
          if (i < this.length-1){
            string += ", "}
        }
        string += "]"
        return string
      }

      LaTeX(){
        let string = "\\begin{bmatrix} \n"
        for (let i=0; i<this.rowDim; i++){
          for (let j=0; j<this.colDim; j++){
            string += String(this[i][j]) + " "
            if (j < this.colDim-1){
              string += "& "}
          } 
          if (i < this.rowDim-1){
            string += "\\\\\n"}
        }
        string += "\n\\end{bmatrix}"
        return string
      }

      equals(that){
        if (!that instanceof RationalMatrix){
          return false}
        if (this.rowDim != that.rowDim || this[0].colDim != that[0].colDim){
          return false}
        for (let i=0; i<this.rowDim; i++){
          for (let j=0; j<this.colDim; j++){
            if (this[i][j].doesNotEqual(that[i][j])){
              return false}
          }
        }
        return true
      }

      doesNotEqual(that){
        return !this.equals(that)}

      transpose(){
        let matrixM = []
        for (let j=0; j<this.colDim; j++){
          row = []
          for (let i=0; i<this.rowDim; i++){
            row.push(this[i][j])
          }
          matrixM.push(row)
        }
        return new RationalMatrix(matrixM)
      }

      add(that){
        let matrixM = []
        for (let i=0; i<this.rowDim; i++){
          row = []
          for (let j=0; j<this.colDim; j++){
            row.push(this[i][j].add(that[i][j]))
          }
          matrixM.push(row)
        }
        return new RationalMatrix(matrixM)
      }

      negate(){
        let matrixM = []
        for (let i=0; i<this.rowDim; i++){
          row = []
          for (let j=0; j<this.colDim; j++){
            row.push(this[i][j].negate())
          }
          matrixM.push(row)
        }
        return new RationalMatrix(matrixM)
      }

      subtract(that){
        return this.add(that.negate())}

      multiply(that){
        if (this.colDim != that.rowDim){
          alert("Dimensions of matrices must agree.")
          throw new Error("Dimensions of matrices must agree.")
        }

        let matrixM = []
        for (let i=0; i<this.rowDim; i++){
          row = []
          for (let j=0; j<that.colDim; j++){
            let sum = parseRational("0")
            for (let k=0; k<this.colDim; k++){
              sum = sum.add(this[i][k].multiply(that[k][j]))}
            row.push(sum)
          }
          matrixM.push(row)
        }
        return new RationalMatrix(matrixM)
      }

      swapRows(ithRow, jthRow){
        if (ithRow>=this.rowDim || jthRow>=this.rowDim){
          throw new Error("Row index out of reach.")}
        let matrixM = []
        for (let k=0; k<this.rowDim; k++){
          if (k!=ithRow && k!=jthRow){
            matrixM.push(this[k])}
          else {
            matrixM.push(this[ithRow+jthRow-k])}
        }
        return new RationalMatrix(matrixM)
      }

      scaleRows(ithRow, cScalar){
        if (ithRow >= this.rowDim){
          throw new Error("Row index out of reach.")}
        let matrixM = []
        for (let k=0; k<this.rowDim; k++){
          if (k != ithRow){
            matrixM.push(this[k])}
          else {
            row = []
            for (let h=0; h<this.colDim; h++){
              row.push(this[k][h].multiply(parseRational(cScalar)))
            }
            matrixM.push(row)
          }
        }
        return new RationalMatrix(matrixM)
      }

      addRows(ithRow, jthRow, cScalar){
        if (ithRow>=this.rowDim || jthRow>=this.rowDim){
          throw new Error("Row index out of reach.")}
        let matrixM = []
        for (let k=0; k<this.rowDim; k++){
          if (k != jthRow){
            matrixM.push(this[k])}
          else {
            row = []
            for (let h=0; h<this.colDim; h++){
              let entry = this[k][h].add(this[ithRow][h].multiply(parseRational(cScalar)))
              row.push(entry)
            }
            matrixM.push(row)
          }
        }
        return new RationalMatrix(matrixM)
      }

      limitColumns(start, end){
        n = this.colDim
        if (start >= end){
          throw new Error("Starting index must be smaller than ending index.")}
        if (start > n || end <= 1){
          throw new Error("Column indices should range between 1 and " + n + ".")}
        if (end > n){
          return this.limitColumns(start-1, n)}
        if (start < 1){
          return this.limitColumns(0, end)}
        let M = []
        for (let i=0; i<this.rowDim; i++){
          M.push(this[i].slice(start-1, end))}
        return new RationalMatrix(M)
      }
    }

    // This class structures a string as a response string that can be compared with other objects 
    class ResponseString{
      constructor(string){
        this.response = string}

      toString(){
        return String(this.response)}

      equals(that){
        return that instanceof ResponseString && this.response == that.response}

      doesNotEqual(that){
        return !this.equals(that)}
    }
  </script>

  <script>
    ////////////////////////////
    // Matrix-Related Methods //
    ////////////////////////////

    /* This script handles matrix input and output.
       It also checks for matrix equality. 
    */

    function readRationalMatrix(string){
      M = []
      for (let i=0; i<3; i++){
        row = []
        for (let j=0; j<6; j++){
          entryAddressM = string+String(i+1)+String(j+1)
          entryM = document.getElementById(entryAddressM)
          row.push(parseRational(entryM.value))
        }
        M.push(row)
      }
      return new RationalMatrix(M)
    }

    function writeRationalMatrix(matrixM, string){
      for (let i=0; i<3; i++){
        for (let j=0; j<6; j++){
          entryAddressM = string+String(i+1)+String(j+1)
          entryM = document.getElementById(entryAddressM)
          entryM.value = String(matrixM[i][j])
        }
      }
    }

    // Assumes that both matrixA and matrixB are instances of RationalMatrix
    function LaTeXifyRowOperation(matrixA, operation, matrixB){
      stringA = matrixA.LaTeX()
      stringB = matrixB.LaTeX()
      let stringOper = "\\xrightarrow{"
      let type = operation[0]
      var ithRow
      var jthRow
      var cScalar
      switch(type){
        case "swap":
          ithRow = operation[1] + 1
          jthRow = operation[2] + 1
          stringOper += "R_{"+ String(ithRow) +"}"
          stringOper += "\\leftrightarrow "
          stringOper += "R_{"+ String(jthRow) +"}"
          break

        case "scale":
          ithRow = operation[1] + 1
          cScalar = operation[2]
          stringOper += String(cScalar) + "\\cdot "
          stringOper += "R_{"+ String(ithRow) +"}"
          break

        case "add":
          ithRow = operation[1] + 1
          jthRow = operation[2] + 1
          cScalar = operation[3]
          stringOper += String(cScalar) + "\\cdot "
          stringOper += "R_{"+ String(ithRow) +"} + "
          stringOper += "R_{"+ String(jthRow) +"}"
          break
      }
      stringOper += "}"

      s = "$$\\small{" + stringA + stringOper + stringB + ".}$$"
      address = document.getElementById("rowOperation")
      address.textContent = s
    }

    // Assumes that matrixA is an instance of RationalMatrix
    function promptMatrix(matrixA, varName){
      stringA = matrixA.LaTeX()
      s = "$$" + varName + " = " + stringA + ".$$"
      address = document.getElementById("itemPrompt")
      address.textContent = s
    }

    function writeTerm(coefficient, variable){
      zero = parseRational("0")
      one = parseRational("1")
      let s = ""
      if (coefficient.equals(zero)){
        return s
      }
      else if (coefficient.negate().equals(one)){
        s += "-"
      }
      else if (coefficient.doesNotEqual(one)){
        s += String(coefficient) + "\\;"
      }
      s += variable 
      return s
    }

    let varString = 'vwxyz'
    function writeEquation(row){
      let s = ""
      let leftmostFound = false
      zero = parseRational("0")
      for (let j=0; j<5; j++){
        // This adds a '+' in front of positive coefficients only if
        // it is not the first nonzero coefficient in the row
        if (j > 0 && row[j].greaterThan(zero) && leftmostFound){
          s += "+"}
        if (row[j].doesNotEqual(zero) && !leftmostFound){
          leftmostFound = true}
        s += writeTerm(row[j], varString[j])
      }
      s += " &= " + String(row[5])
      return s 
    }

    function promptEquation(matrixC){
      let stringEqns = "\\begin{aligned}\n"
      for (let i=0; i<matrixC.rowDim; i++){
        stringEqns += writeEquation(matrixC[i])
        if (i < matrixC.rowDim-1){
          stringEqns += "\\\\\n"}
      }
      stringEqns += "\n\\end{aligned}" 
      s = "$$" + stringEqns + "$$"
      address = document.getElementById("itemPrompt")
      address.textContent = s
    }

    /* This function disables unnecessary parameters to prevent users from changing 
       their values */
    function disableParameters(){
      type = document.getElementById("operationType").value
      jthRow = document.getElementById("row_j")
      scalingFactor = document.getElementById("scalar")
      switch(type){ 
        case "swap":
          jthRow.disabled = false
          scalingFactor.disabled = true
          break

        case "scale":
          jthRow.disabled = true
          scalingFactor.disabled = false
          break

        default:
          jthRow.disabled = false
          scalingFactor.disabled = false
          break
      }
    }
  </script>

  <script>
    /* 
      This script handles question display, grading and scoring.
      Furthermore, it tracks performed row operations. 
      It also contains page navigational features. 
    */

    var Module_Number = '09'
    page = 0
    initialized = 0
    quests = [
      "1. Apply row operations to find the r.r.e.f. for the matrix $A$ displayed on the right.",
      "2. Good, now find the r.r.e.f. for this matrix $A$.",
      "3. Nicely done! Next, what is the r.r.e.f of this matrix $A$?",
      "4. Could you determine the r.r.e.f of this matrix $A$?",
      "5. Good job! Now, determine if the given matrix $B$ has an inverse. If so, return the r.r.e.f. with this inverse matrix.",
      "6. Alright, does this matrix $B$ over here have an inverse?",
      "7. Great, can you find the inverse, if any, for this matrix $B$?",
      "8. Does matrix $B$ over here have an inverse?",
      "9. Consider the following system of linear equations. What values can $x$ take?",
      "10. What values can $w$ take in this system of linear equations?",
      "11. Awesome, what values can $z$ assume for this system of linear equations?",
      "12. Nice, what values can $y$ assume in the given system of linear equations?",
      "Terrific!"
    ]

    // Records User Responses to SQL database
    the_time = Date.now()
    make_grades(Module_Number)

    /////////////////////////////
    // Page navigation buttons //
    /////////////////////////////

    function nextPage(){
      if (page<quests.length && initialized==1){
        document.getElementById("response").textContent = ""
        clearRowOperation()
        page += 1
        displayQuestion(page)}
    }

    function previousPage(){
      if (page>0 && initialized==1){
        document.getElementById("response").textContent = ""
        clearRowOperation()
        page -= 1
        displayQuestion(page)}
    }

    function automaticSucceed(){
      if (initialized != 1){
        return }
      appendCompletedQuestion(page)
      if (page < quests.length){
        page += 1}
      clearRowOperation()
      displayQuestion(page)
    }

    ////////////////////////////
    // Row operation tracking //
    ////////////////////////////

    // These form the internal memory for stored row operations and matrices
    let matrixList = []
    let operationList = []
    let newMatrix = null
    let newOperation = null
    
    function previewRowOperation(){
      /* 
        Applies and previews an elementary row operation
        Temporarily stores the new matrix and row operation
      */
      let selected = true

      type = document.getElementById("operationType").value
      ithRow = document.getElementById("row_i")
      jthRow = document.getElementById("row_j")
      scalingFactor = document.getElementById("scalar")

      let A = readRationalMatrix('a')
      switch(type){
        case "swap":
          i = ithRow.value - 1
          j = jthRow.value - 1
          if (i===j){
            alert("The row indices must be distinct.")
            break}
          newMatrix = A.swapRows(i, j)
          newOperation = ["swap", i, j]
          break

        case "scale":
          i = ithRow.value - 1
          c = parseRational(scalingFactor.value)
          newMatrix = A.scaleRows(i, c)
          newOperation = ["scale", i, c]
          break

        case "add":
          i = ithRow.value - 1
          j = jthRow.value - 1
          if (i===j){
            alert("The row indices must be distinct.")
            break}
          c = parseRational(scalingFactor.value)
          newMatrix = A.addRows(i, j, c)
          newOperation = ["add", i, j, c]
          break

        case "null":
          selected = false
          break
      }

      if (!selected){
        return }
      writeRationalMatrix(newMatrix, "b")
      displayRowOperation(A, newOperation, newMatrix)
    }

    function commitRowOperation(){
      /* 
        Commits the performed row operation and adds the new matrix and row operation 
        into memory
        
        Should the user decides to commit a (matrix, row operation) pair that 
        is not possible from the most recent ones, all previous matrices and 
        row operations are removed from memory and the new pair is committed instead
      */
      if (newMatrix === null || newOperation === null){
        return }
      A = readRationalMatrix('a')
      if (matrixList.length == 0){
        matrixList.push(A)
      }
      else if (matrixList[matrixList.length-1].doesNotEqual(A)) {
        matrixList = []
        operationList = []
        matrixList.push(A)
      }
      matrixList.push(newMatrix)
      operationList.push(newOperation)
      writeRationalMatrix(newMatrix, 'a')
      
      newMatrix = null
      newOperation = null
    }

    function undoRowOperation(){
      /* 
       Rolls back the most recently committed row operation and removes 
       the corresponding a (matrix, row operation) pair from memory
      */
      if (operationList.length == 0){
        return }
      if (operationList.length > 1){
        A = matrixList[matrixList.length-3]
        B = matrixList[matrixList.length-2]
        operation = operationList[operationList.length-2]
        matrixList.pop()
        operationList.pop()
        displayRowOperation(A, operation, B)
        writeRationalMatrix(A, 'a')
        writeRationalMatrix(B, 'b')
      }
      else {
        matrixList.pop()
        matrixList.pop()
        operationList.pop()
        showRow("false")
      }
    }

    function showRow(option){
      // Shows or hides all elements in the Performed Row Operation area
      parent = document.getElementsByClassName("displayArea")[0]
      children = parent.children
      for (let i=0; i<children.length; i++){
        child = children[i]
        if (option == "true"){
          child.classList.remove("hidden")
        }
        else if (option == "false"){
          child.classList.add("hidden")
        }
      }
    }

    function displayRowOperation(matrixA, operation, matrixB){
      // Adds row operation preview
      showRow("true")
      LaTeXifyRowOperation(matrixA, operation, matrixB)
      MathJax.typesetPromise()
    }

    function clearRowOperation(){
      // Removes row operation preview and resets internal memory
      showRow("false")
      matrixList = []
      operationList = []
      newMatrix = null
      newOperation = null
    }

    ///////////////////////////////
    // Grading related functions //
    ///////////////////////////////

    answers = [
      new RationalMatrix([[1,0,0,-1,1,-1],[0,1,0,0,-2,2],[0,0,1,0,0,-3]]),
      new RationalMatrix([[1,"1/2",0,0,"-1/2","3/2"],[0,0,1,0,0,2],[0,0,0,1,"1/3","-2/3"]]),
      new RationalMatrix([[1,0,0,0,"-2/5","3/5"],[0,1,"2/5",0,"1/5","-1/5"],[0,0,0,0,0,0]]),
      new RationalMatrix([[1,0,0,6,-12,54],[0,1,0,5,-4,33],[0,0,1,-2,9,-22]]),
      new RationalMatrix([[1,0,0,"1/2","-1/4","1/6"],[0,1,0,"-1/2","-1/4","1/6"],[0,0,1,"-1/2","-1/4","-1/6"]]),
      new ResponseString("No Inverse"),
      new ResponseString("No Inverse"),
      new RationalMatrix([[1,0,0,"1/9","-1/2","5/27"],[0,1,0,"1/9",0,"-4/27"],[0,0,1,"-1/9",0,"-5/27"]]),
      new ResponseString("Any Real Value"), 
      parseRational("-2"), 
      new ResponseString("Any Real Value"), 
      parseRational("1/3")]
    function gradeAnswer(page, response){
      // Defines the grading of a submitted answer
      correct = "false"
      reference = answers[page]
      if (response.equals(reference)){
        correct = "true"
      }
      return correct
    }

    function appendCompletedQuestion(page){
      /* 
        Adds a recently completed question if no correct attempt was 
        submitted before
      */
      if (grades[page][0] == 1){
        score()

        var answeredQuestion = document.createElement('div')
        answeredQuestion.textContent = quests[page]
        answeredQuestion.setAttribute('class', 'greytext')
        document.getElementById("completed").appendChild(answeredQuestion)}
    }

    Default = new RationalMatrix([[1,0,0,1,1,0],[0,1,0,2,0,2],[0,0,1,0,3,3]])
    questionPrompts = [
      new RationalMatrix([[1,-3,7,-1,7,-28],[0,-1,2,0,2,-8],[0,2,-3,0,-4,13]]),
      new RationalMatrix([[4,2,0,12,2,-2],[-2,-1,1,-3,0,1],[2,1,3,18,5,-3]]),
      new RationalMatrix([[1,4,"8/5",0,"2/5","-1/5"],[2,5,2,0,"1/5","1/5"],[3,10,4,0,"4/5","-1/5"]]),
      new RationalMatrix([[1,-1,1,-1,1,-1],[1,2,4,8,16,32],[1,-3,9,-27,81,-243]]),
      new RationalMatrix([[1,-1,0,1,0,0],[-2,0,-2,0,1,0],[0,3,-3,0,0,1]]),
      new RationalMatrix([[1,-1,2,1,0,0],[2,3,0,0,1,0],[0,5,-4,0,0,1]]),
      new RationalMatrix([[0,"3/4","1/3",0,1,0],["2/5","-1/4",0,1,0,0],["-6/5",0,"-1/3",0,0,1]]),
      new RationalMatrix([[0,5,-4,1,0,0],[-2,0,-2,0,1,0],[0,-3,-3,0,0,1]]),
      new RationalMatrix([[1,1,2,-1,2,-1],[0,0,1,1,-2,2],[1,0,0,-3,6,-9]]),
      new RationalMatrix([[-4,6,2,8,10,-19],[-8,8,4,4,17,-24],[2,-2,-1,0,-4,"11/2"]]),
      new RationalMatrix([[1,1,2,-5,8,4],[2,1,4,-3,6,9],[3,0,6,3,-3,15]]),
      new RationalMatrix([[6,-2,12,9,-4,-3],[-3,1,-6,-3,2,2],[-3,1,6,-6,-2,-5]])]

    function displayQuestion(page){
      // Handles the display of questions and question prompts
      landingArea = document.getElementById("questionToDisplay") 
      landingArea.innerHTML = quests[page]

      A = questionPrompts[page]
      buttonAddress = document.getElementById("alternateAnswer")
      variableAddress = document.getElementById("variable")
      textAddress = document.getElementById("value")
      if (page<8){
        if (page<4){
          promptMatrix(A, 'A')
          buttonAddress.classList.add("hidden")
          variableAddress.classList.add("hidden")
          textAddress.classList.add("hidden")
        }
        else {
          B = A.limitColumns(1, 3)
          promptMatrix(B, 'B')
          buttonAddress.classList.remove("hidden")
          buttonAddress.textContent = "No Inverse"
          variableAddress.classList.add("hidden")
          textAddress.classList.add("hidden")
        }
        writeRationalMatrix(A, "a")
        writeRationalMatrix(A, "b")
      }
      else if (8<=page && page<12){
        promptEquation(A)
        buttonAddress.classList.remove("hidden")
        buttonAddress.textContent = "Any Real Value"
        variableAddress.classList.remove("hidden")
        variableString = 'xwzy'
        variableAddress.textContent = "Value of $" + variableString[page-8] + "$:"
        textAddress.classList.remove("hidden")

        writeRationalMatrix(A, "a")
        writeRationalMatrix(A, "b")
      } 
      else {
        document.getElementById("itemPrompt").textContent=""
        writeRationalMatrix(Default, "a")}
      MathJax.typesetPromise()
    }

    function resetSettings(){
      /* 
        This functions resets the row operations settings and rewrites the matrix 
        for the page
      */
      let i = 1
      let j = 1
      let c = 1

      // This resets the settings for row operations
      document.getElementById("operationType").value = "null"
      document.getElementById("row_i").value = i
      document.getElementById("row_j").value = j
      document.getElementById("scalar").value = c
      disableParameters()
      
      // This resets the matrices' entries
      if (initialized==1 && page<12){
        writeRationalMatrix(questionPrompts[page], "a")
        writeRationalMatrix(questionPrompts[page], "b")
      }
      else {
        writeRationalMatrix(Default, "a")
        writeRationalMatrix(Default, "b")
      }
    }

    function updateCorrect(pageNum){
      grades[page][0]+=1
      document.getElementById("response").textContent = ""
      appendCompletedQuestion(page)
      nextPage()
    }

    function pointOut(){
      reply = document.getElementById("response")
      texts = ["Not quite, please try again.", 
               "This is slightly incorrect, please check once more.",
               "You're almost there, don't give up!"]
      for (let i=0; i<texts.length; i++){
        if (reply.textContent == texts[i]){
          reply.textContent = texts[(i+1)%3]
          return 
        }
      }
      reply.textContent = texts[0]
    }

    function updateIncorrect(pageNum){
      grades[page][1]+=1
      pointOut()
    }

    function gradeSubmission(mode){
      /* 
        This function defines the behavior after the submission of an incorrect 
        or a correct attempt 
      */       
      if (initialized == 0){
        button = document.getElementById("submitButton")
        button.textContent = "Submit"
        initialized = 1
        clearRowOperation()
        displayQuestion(0)
        return }
      else if (initialized == 1){
        if (page >= quests.length){
          return }

        A = readRationalMatrix("a")
        correctAnswer = false
        if (page<4){
          if (mode === 'matrix' && gradeAnswer(page, A) == "true"){
            correctAnswer = true}
        }
        /* 
        For questions 4 through 12
        If user enters a matrix or a number, then the function compares its value against the answer
        Otherwise, the user enters an alternate answer and the function compares the response against 
        the answer
        */
        else if (4<=page && page<8){
          if (mode === 'matrix'){
            if (gradeAnswer(page, A) == "true"){
              correctAnswer = true}
          }
          else if (mode === 'alternate'){
            let response = new ResponseString("No Inverse")
            if (gradeAnswer(page, response) == "true"){
              correctAnswer = true}
          }
        }
        else if (8<=page && page<12){
          if (mode === 'matrix'){
            let number = parseRational(document.getElementById("value").value)
            if (gradeAnswer(page, number) == "true"){
              correctAnswer = true}
          }
          else if (mode === 'alternate'){
            let response = new ResponseString("Any Real Value")
            if (gradeAnswer(page, response) == "true"){
              correctAnswer = true}
          }
        }

        if (correctAnswer){
          updateCorrect(page)}
        else {
          updateIncorrect(page)}
      }
      sql_record(Module_Number)
    }
  </script>
</body>
</html>