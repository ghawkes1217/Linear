<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Linear Algebra: Complete Solution to the System Ax=b</title>

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]},
    }
  </script>

  <!-- The following adds MathJax to render LaTeX notation -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>

  <link rel="stylesheet" href="../styles.css">

  <script src="../site-scripts.js"></script>

  <style type="text/css">
    #blank {
      position: relative;}

    .variables {
      position: absolute;
      background-color: white;
      font-size: 22px;
      top: 50px;
      width: 55px;
      height: 35px;}

    .solutionSet{
      position: absolute;
      background-color: lightyellow;
      top: 100px;
      width: 45px;
      height: 25px;}

    #outer {
      position: absolute;
      left: 0px;
      top: 210px;
      text-align: center;}

    #equations {
      position: absolute;
      height: 300px;
      width: 350px;
      left: 800px;
      top: 250px;
      background-color: black;
      text-align: center;}
    
    #line {
      position: absolute;
      height: 280px;
      width: 5px;
      left: 400px;
      top: 0px;
      background-color: black;}

    .center {
      text-align: center;
      font-size: 30px;}

    .separators {
      top: 40px;
      position: absolute;
      background-color: black;
      width: 10px;}

    .scalarInputs {
      position: absolute;
      background-color: lightyellow;
      left: 5px;
      font-size: 22px;
      width: 55px;
      height: 40px;}

    .switches {
      position: absolute;
      background-color: white;
      height: 20px;
      left: 100px;
    }

    .multiplyButtons {
      font-size: 22px;
      position: absolute;
      height: 46px;
      width: 28px;
      left: 70px;
      background-color: silver}

    .matrixRows {
      position: absolute;
      height: 55px;
      left: 100px;
      opacity: 0.8;}

    .matrixColumns {
      position: absolute;
      height: 45px;
      width: 75px;
      top: 10px;
      opacity: 0.8;
      background-color: #FFFFFF10;}

    #score {
      position: absolute;
      height: 220px;
      width: 90px;
      left: 1200px;
      top: 0px;
      background-color: white;
      text-align: center;}

    .systems {
      display: flex;
      justify-content: space-around;}

    .equationElement {
      position: absolute;
      width: 260px;
      height: 30px;
      font-size: 20px;
      left: 50px;}
  </style>
</head>

<body>
  <div style="position: absolute;">
    <a href="../linear-lab.html" class="backto">&#8592 Back to Linear Lab</a>
  </div>
<h2><center>Module 14: Complete Solution to the System $Ax=b$</center></h2>

<div class="introduction">
  <p>
    Take a look at these three different systems of 3 linear equations:
    <ul class='systems'>
      <li> <b>System 1</b>
        $$\begin{aligned}
        x+y &= 1,\\
        y+z &= 2,\\
        x+z &= 3.\\ 
        \end{aligned}$$
      </li>
      <li> <b>System 2</b>
        $$\begin{aligned}
        x+y &= 1,\\
        y+z &= 2,\\
        x-z &= -1.\\ 
        \end{aligned}$$
      </li>
      <li> <b>System 3</b>
        $$\begin{aligned}
        x+y &= 1,\\
        y+z &= 2,\\
        x-z &= 3.\\ 
        \end{aligned}$$
      </li>
    </ul>
  </p>

  <p>
    In System 1, we can figure out the values of $x,y,z$ by first adding all three equations to produce $2x+2y+2z=6$, so that $x+y+z=3$. Subtracting each of the three equations from this one respectively gives $z=2, x=1, y=0$. This gives precisely the only set of solutions that solves System 1.
  </p>

  <p>
    Next, for System 2, we may infer the third equation by subtraction the first by the second, that is, 
    $$x-z = (x+y)-(y+z) = 1-2 =-1,$$
    This gives us some freedom to vary the value of $y$, so that the values of $x$ and $z$ can be inferred from the first two equations. 
    For example, we may have $y=0$ and thus that $x=1-y=1-0=1$ and $z=2-y=2-0=2$.
    If instead, we had chosen $y=1$, we would have $x=1-y=1-1=0$ and $z=2-y=2-1=1$.
    Both cases (and in fact, many more) are valid sets of solutions to this system.
  </p>

  <p>
    Finally, within System 3, we could similarly subtract the first equation by the second to obtain $x-z=-1$.
    However, this clearly contradicts the third equation, which says that $x-z=3$ as well.
    In this case, there are no values of $x$, $y$ and $z$ that satisfy all of these equations.
  </p>
  
  <p>
    Although these three systems are systems of 3 linear equations in 3 variables, their behaviors all differ:
    <ul>
      <li> One system yields a unique set of solutions,</li>
      <li> Another system yields more than one set of solutions,</li>
      <li> Yet another system cannot have a consistent set of solutions due to an inherent contradiction.</li>
    </ul>
  </p>
  
  <p>
    How do we distinguish these behaviors, you ask? For starters, consider the following framework. Suppose you have a system of $m$ linear equations in variables $x_1, x_2, x_3 \ldots, x_n$

    $$\begin{alignedat}{5}
      a_{1,1} x_1 & + a_{1,2} x_2 & + \ldots & + a_{1,n} x_n & = c_1,\\
      a_{2,1} x_1 & + a_{2,2} x_2 & + \ldots & + a_{2,n} x_n & = c_2,\\
      \vdots      &               &   \vdots &               & \\
      a_{m,1} x_1 & + a_{m,2} x_2 & + \ldots & + a_{m,n} x_n & = c_m,\\
    \end{alignedat}$$

    with real constants $a_{i,j}$ and $c_i$, where $1\leq i\leq m$, $1\leq j\leq n$.
    We may compress this as a matrix equation $Ax=b$ by setting 
    $$A = 
    \begin{bmatrix}
      a_{1,1} & a_{1,2} & \ldots & a_{1,n}\\
      a_{2,1} & a_{2,2} & \ldots & a_{2,n}\\
      \vdots  & \vdots  & \ddots & \vdots\\
      a_{m,1} & a_{m,2} & \ldots & a_{m,n}\\
    \end{bmatrix},\quad 
    x = \begin{bmatrix} x_1\\ x_2\\ \vdots\\ x_n \end{bmatrix},\quad 
    b = \begin{bmatrix} c_1\\ c_2\\ \vdots\\ c_m \end{bmatrix}.$$
    
    We may compute the r.r.e.f. of the augmented matrix $M=[A\;|\; b\;]$ to simplify our viewpoint of the same system. Based on the r.r.e.f. $M'$ of $M$, we could deduce three distinct behaviors:
    <ul>
      <li> 
        All columns of the left part of $M'$ contain a pivot. In this case, the values of each variable is unique and we may read off each of the values from the rows of $M'$.

        As an example, the augmented matrix associated to System 1 has its r.r.e.f. to be
      
        $$ M' = \begin{array}{c}
        \begin{array}{llll}
        \hspace{-5pt} x & y & z & \\
        \end{array}\\
        \left[\begin{array}{ccc|c}
        1 & 0 & 0 & 1\\
        0 & 1 & 0 & 0\\
        0 & 0 & 1 & 2\\
        \end{array}\right]\\
        \end{array},$$
        therefore, we have $(x,y,z)=(1,0,2)$.
        This system is said to be <b><em>consistent</em></b> as we have a solution set.
      </li>
      <li> 
        Not all columns on the left part of $M'$ contain a pivot; furthermore, whenever there is a row of zeros on the left part of $M'$, it is followed by a 0. In this case, each column containing a pivot corresponds to a <b><em>pivot variable</b></em> whereas each column that does not contain a pivot corresponds to a <b><em>free variable</b></em>. 

        For instance, the augmented matrix associated to System 2 has its r.r.e.f. to be
      
        $$ M' = \begin{array}{c}
        \begin{array}{llll}
        \hspace{-20pt} x & \hspace{-15pt} y & \hspace{-5pt} z & \\
        \end{array}\\
        \left[\begin{array}{ccc|c}
        1 & 0 & -1 & -1\\
        0 & 1 & 1 & 2\\
        0 & 0 & 0 & 0\\
        \end{array}\right]\\
        \end{array}.$$

        In this case, $x$ and $y$ are pivot variables, whereas $z$ is a free variable. 
        If we set $z=t$ for some real value $t$, we have $x=-1+z=-1+t$ and $y=2-z=2-t$, so that $(x,y,z)=(-1+t,2-t,t)$.

        In general, note that there are multiple valid sets of solutions that can be obtained by varying the values of each free variable. 
        Similar to the previous case, this system is said to be <b><em>consistent</em></b> as we also have at least one solution set.
      </li>
      <li> 
        Not all on the left part of $M'$ contain a pivot; furthermore, there is a row of zeros on the left part of $M'$ but is followed by a nonzero entry.

        In this case, there is no consistent set of values that can be assigned to each variable. We would have no solution here. 

        For instance, the augmented matrix associated to System 3 has its r.r.e.f. to be
      
        $$ M' = \begin{array}{c}
        \begin{array}{llll}
        \hspace{-15pt}x & \hspace{-10pt} y & z & \\
        \end{array}\\
        \left[\begin{array}{ccc|c}
        1 & 0 & -1 & 0\\
        0 & 1 & 1 & 0\\
        0 & 0 & 0 & 1\\
        \end{array}\right]\\
        \end{array}.$$
        Now, as the last row is a bunch of zeros followed by a 1, we cannot find a set of values for $x,y,z$ that satisfy the original system of equations.
        This system is said to be <b><em>inconsistent</em></b>.
      </li>
    </ul>
  </p>
</div>
  
<div class="instruction">
  <p>
    For this module, your task is to perform the following:
    <ul>
      <li>
        Determine whether or not a given system of equations is consistent.
      </li>
      <li>
        Determine the nature of the nullspace associated to a given system of equations.
      </li>
      <li>
        Find a set of solutions given another set of solutions when multiple solutions exist.
      </li>
    </ul>
    In all of the questions, please demonstrate your work by putting the matrix in r.r.e.f. (Refer to Module 11 in case you wish to review this.)
  </p>

  <!--<p>
    You may perform row operations onto the matrix shown below:
    <ul>
      <li>
        To swap two rows, drag one of them and release it onto another, 
      </li>
      <li>
        To scale a row, enter a rational number (of the form $a/b$) next to that row and click on the $\times$ symbol next to it,
      </li>
      <li>
        To add a multiple of one row to another, enter a rational number next to the row to be multiplied, then drag release it onto the target row.
      </li>
    </ul>
    The result is always shown on the screen to the right of the matrix. 
    Feel free to hit 'Undo' if you would like to backtrack some performed operations.
  </p>-->

  <p> Interactives to be added at a later date.
</div>

<script type="text/javascript">
  // Returns the gcd of two integers
  function gcd(a, b){
    if (a == 0 && b == 0){
      throw "Both integers cannot be both zero."
      return }
    if (a == 0){
      return Math.abs(b)}
    if (b == 0){
      return Math.abs(a)}
    if (b < 0){
      return gcd(a, -b)}
    if (a < 0){
      return gcd(-a, b)}
    return gcd(b, a%b)
  }

  // Defines a class of rational numbers
  class RationalNumber{
    constructor(a, b){
      if (b < 0){
        a = -a
        b = -b}
      let d = gcd(a,b)
      this.numerator = a/d
      this.denominator = b/d}

    toString(){
      if (this.denominator==1){
        return String(this.numerator)}
      return String(this.numerator)+"/"+String(this.denominator)}

    equals(that){
      return that instanceof RationalNumber && 
             this.numerator == that.numerator && 
             this.denominator == that.denominator
    }

    doesNotEqual(that){
      return !this.equals(that)}

    greaterThan(that){
      return this.numerator*that.denominator > this.denominator*that.numerator}

    greaterThanOrEquals(that){
      return this.numerator*that.denominator >= this.denominator*that.numerator}

    lessThan(that){
      return !this.greaterOrEquals(that)}

    lessThanOrEquals(that){
      return !this.greaterThan(that)}

    add(that){
      let m = this.numerator*that.denominator + this.denominator*that.numerator
      let n = this.denominator*that.denominator
      return new RationalNumber(m, n)}

    negate(){
      return new RationalNumber(-this.numerator, this.denominator)}

    subtract(that){
      return this.add(that.negate())}

    multiply(that){
      let m = this.numerator*that.numerator
      let n = this.denominator*that.denominator
      return new RationalNumber(m, n)}

    invert(){
      if (this.numerator==0){
        alert("One does not simply divide by zero.")}
      return new RationalNumber(this.denominator, this.numerator)}

    divide(that){
      return this.multiply(that.invert())}
  }

  function parseRational(input){
    // if input is already an instance of a rational number, do nothing
    if (input instanceof RationalNumber){
      return input}

    // if input is an integer, return is as a rational number
    if (!isNaN(input) && parseInt(input)==input){
      return new RationalNumber(input, 1)}

    n = input.length
    let numberExist = [false, false]
    let index = -1
    for (let i=0; i<n; i++){
      if (input[i] == '-'){
        if (i!=index+1 || i==n-1){
          throw new Error("This is not a rational number.")
          return 
        } 
      } 
      else if (input[i] == '/'){
        if (i==0 || i==n-1 || index>0){
          throw new Error("This is not a rational number.")
          return 
        }
        index = i
      }
      else if (isNaN(input[i])){
        throw new Error("This is not a rational number.")
        return 
      } 
      else {
        if (!numberExist[0] && index==-1){
          numberExist[0] = true} 
        else if (!numberExist[1] && index > 0){
            numberExist[1] = true} 
      }
    }

    if(index==-1){
      if (!numberExist[0]){
        throw new Error("This is not a rational number.")
        return }
      let a = parseInt(input)
      return new RationalNumber(a, 1)}

    if (!numberExist[0] || !numberExist[1]){
      throw new Error("This is not a rational number.")
      return }
    let a = parseInt(input.slice(0, index))
    let b = parseInt(input.slice(index+1, n))
    return new RationalNumber(a, b)
  }

  // Defines a class of rational-valued matrices
  class RationalMatrix extends Array{
    constructor(M){
      for (let i=1; i<M.length; i++){
        if (M[i].length != M[0].length){
          alert("Given array must be rectangular.")
          throw new Error("Given array must be rectangular.")
        }
      }

      let matrixM = []
      for (let i=0; i<M.length; i++){
        let row = []
        for (let j=0; j<M[0].length; j++){
          let entry = parseRational(M[i][j])
          if (entry == undefined){
            throw new Error("Entry is not a rational number.")
            return 
          }
          row.push(entry)
        }
        matrixM.push(row)
      }
      super(...matrixM)
      this.rowDim = matrixM.length
      this.colDim = matrixM[0].length
      }

    toString(){
      let string = "["
      for (let i=0; i<this.length; i++){
        string += "["
        for (let j=0; j<this[0].length; j++){
          string += this[i][j].toString()
          if (j < this[i].length-1){
            string += ", "
          }
        }
        string += "]"
        if (i < this.length-1){
          string += ", "}
      }
      string += "]"
      return string
    }

    LaTeX(){
      let string = "\\begin{bmatrix} \n"
      for (let i=0; i<this.rowDim; i++){
        for (let j=0; j<this.colDim; j++){
          string += String(this[i][j]) + " "
          if (j < this.colDim-1){
            string += "& "}
        } 
        if (i < this.rowDim-1){
          string += "\\\\\n"}
      }
      string += "\n\\end{bmatrix}"
      return string
    }

    equals(that){
      if (!that instanceof RationalMatrix){
        return false}
      if (this.rowDim != that.rowDim || this[0].colDim != that[0].colDim){
        return false}
      for (let i=0; i<this.rowDim; i++){
        for (let j=0; j<this.colDim; j++){
          if (this[i][j].doesNotEqual(that[i][j])){
            return false}
        }
      }
      return true
    }

    doesNotEqual(that){
      return !this.equals(that)}

    transpose(){
      let matrixM = []
      for (let j=0; j<this.colDim; j++){
        row = []
        for (let i=0; i<this.rowDim; i++){
          row.push(this[i][j])
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    add(that){
      let matrixM = []
      for (let i=0; i<this.rowDim; i++){
        row = []
        for (let j=0; j<this.colDim; j++){
          row.push(this[i][j].add(that[i][j]))
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    negate(){
      let matrixM = []
      for (let i=0; i<this.rowDim; i++){
        row = []
        for (let j=0; j<this.colDim; j++){
          row.push(this[i][j].negate())
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    subtract(that){
      return this.add(that.negate())}

    multiply(that){
      if (this.colDim != that.rowDim){
        throw new Error("Dimensions of matrices must agree.")
        return 
      }

      let matrixM = []
      for (let i=0; i<this.rowDim; i++){
        row = []
        for (let j=0; j<that.colDim; j++){
          let sum = parseRational("0")
          for (let k=0; k<this.colDim; k++){
            sum = sum.add(this[i][k].multiply(that[k][j]))}
          row.push(sum)
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    annihilates(vector){
      if (vector.length != this.colDim){
        return false}

      let zero = new RationalNumber(0, 1)
      for (let i=0; i<this.rowDim; i++){
        let sum = zero
        for (let j=0; j<this.colDim; j++){
          sum = sum.add(this[i][j].multiply(vector[j]))
        }
        if (sum.doesNotEqual(zero)){
          return false}
      } 
      return true
    }

    leftAnnihilates(vector){
      if (vector.length != this.rowDim){
        return false}

      zero = new RationalNumber(0, 1)
      for (let j=0; j<this.colDim; j++){
        let sum = zero
        for (let i=0; i<this.rowDim; i++){
          sum = sum.add(this[i][j].multiply(vector[i]))
        }
        if (sum.doesNotEqual(zero)){
          return false}
      } 
      return true
    }

    swapRows(ithRow, jthRow){
      if (ithRow>=this.rowDim || jthRow>=this.rowDim){
        throw new Error("Row index out of reach.")
        return 
      }
      let matrixM = []
      for (let k=0; k<this.rowDim; k++){
        if (k!=ithRow && k!=jthRow){
          matrixM.push(this[k])}
        else {
          matrixM.push(this[ithRow+jthRow-k])}
      }
      return new RationalMatrix(matrixM)
    }

    scaleRows(ithRow, cScalar){
      if (ithRow >= this.rowDim){
        throw new Error("Row index out of reach.")
        return
      }
      let matrixM = []
      for (let k=0; k<this.rowDim; k++){
        if (k != ithRow){
          matrixM.push(this[k])}
        else {
          row = []
          for (let h=0; h<this.colDim; h++){
            row.push(this[k][h].multiply(parseRational(cScalar)))
          }
          matrixM.push(row)
        }
      }
      return new RationalMatrix(matrixM)
    }

    addRows(ithRow, jthRow, cScalar){
      if (ithRow>=this.rowDim || jthRow>=this.rowDim){
        throw new Error("Row index out of reach.")
        return
      }
      let matrixM = []
      for (let k=0; k<this.rowDim; k++){
        if (k != jthRow){
          matrixM.push(this[k])}
        else {
          row = []
          for (let h=0; h<this.colDim; h++){
            let entry = this[k][h].add(this[ithRow][h].multiply(parseRational(cScalar)))
            row.push(entry)
          }
          matrixM.push(row)
        }
      }
      return new RationalMatrix(matrixM)
    }

    limitColumns(start, end){
      n = this.colDim
      if (start >= end){
        throw new Error("Starting index must be smaller than ending index.")
        return
      }
      if (start > n || end <= 1){
        throw new Error("Column indices should range between 1 and " + n + ".")
        return
      }
      if (end > n){
        return this.limitColumns(start-1, n)}
      if (start < 1){
        return this.limitColumns(0, end)}
      let M = []
      for (let i=0; i<this.rowDim; i++){
        M.push(this[i].slice(start-1, end))}
      return new RationalMatrix(M)
    }

    appendColumns(columns){
      for (let j=0; j<columns.length; j++){
        if (columns[j].length != this.rowDim){
          throw new Error("The number of rows for each column vector must match with the matrix.")
          return
        }
      }

      A = []
      for (let i=0; i<this.rowDim; i++){
        row = this[i]
        for (let j=0; j<columns.length; j++){
          row.push(columns[j][i])}
        A.push(row)
      }
      return new RationalMatrix(A)
    }
  }

  // This class structures a string as a response string that can be compared with other objects 
  class ResponseString{
    constructor(string){
      this.response = string}

    toString(){
      return String(this.response)}

    equals(that){
      return that instanceof ResponseString && this.response == that.response}

    doesNotEqual(that){
      return !this.equals(that)}
  }
</script>

<script type="text/javascript">
  // Random generation of mathematical objects

  // Returns an integer in the interval [low, high]
  function generateInteger(low, high){
    difference = high - low + 1
    return low + Math.floor(difference * Math.random())
  }

  function generatePermutation(n){
    array = []
    for (let i=0; i<n; i++){
      array.push(i)
    }

    for (let i=0; i<n-1; i++){
      j = i + generateInteger(0, n-1-i)
      temp = array[i]
      array[i] = array[j]
      array[j] = temp
    }
    return array
  }

  function generateSubset(k, n){
    array = []
    for (let i=0; i<n; i++){
      array.push(i)
    }

    for (let i=0; i<k-1; i++){
      j = i + generateInteger(0, n-1-i)
      temp = array[i]
      array[i] = array[j]
      array[j] = temp
    }
    S = array.splice(0, k)
    return S.sort()
  }

  function generateRationalNumber(den, maxRange, allowZero=true){
    maxNum = maxRange * den

    if (allowZero){
      num = generateInteger(-maxNum, maxNum)
      return new RationalNumber(num, den)
    }

    sign = (-1)**generateInteger(0, 1)
    unsignedNum = generateInteger(1, maxNum)
    return new RationalNumber(sign*unsignedNum, den)
  }

  function generateRationalTuple(rank){
    scalars = []
    den = generateInteger(1, 4)
    for (let i=0; i<rank; i++){
      scalars.push(generateRationalNumber(den, 2))
    }
    return scalars
  }

  // Generates an invertible rational (rxr)-upper or lower triangular matrix
  function generateRationalTriangularMatrix(rank, upper=true, maxDensity=1){
    zero = new RationalNumber(0, 1)
    M = []
    for (let i=0; i<rank; i++){
      row = []
      den = generateInteger(1, 4)
      for (let j=0; j<rank; j++){
        if ((i>j && upper) || (i<j && !upper)){
          row.push(zero)}
        else if (i==j){
          row.push(generateRationalNumber(den, 3, allowZero=false))}
        else {
          flagValue = Math.random()
          if (flagValue >= maxDensity){
            row.push(zero)}
          else {
            row.push(generateRationalNumber(den, 3))}
        }
      }
      M.push(row)
    }
    return new RationalMatrix(M)
  }

  // Generates a rational (mxr)-matrix with rank r
  // where m is the number of rows
  function generateRationalFixedRankMatrix(rowNum, rank){
    if (rank > rowNum){
      throw "Rank needs to be at most the number of rows."}

    L = generateRationalTriangularMatrix(rank, upper=false, maxDensity=0.5)
    U = generateRationalTriangularMatrix(rank, upper=true, maxDensity=0.5)
    A = L.multiply(U)

    G = []
    for (let i=0; i<rowNum; i++){
      if (i < rank){
        G.push(A[i])}
      else {
        G.push(generateRationalTuple(rank))}
      }
    return new RationalMatrix(G) 
  }

  // Generates a rational (rxn)-matrix in RREF with rank r
  function generateRationalRREF(colNum, rank){
    S = generateSubset(rank, colNum)
    R = []

    for (let i=0; i<rank; i++){
      row = []
      den = generateInteger(1, 4)
      for (let j=0; j<colNum; j++){
        if (j < S[i]){
          row.push(new RationalNumber(0, 1))}
        else if (j == S[i]){
          row.push(new RationalNumber(1, 1))}
        else if (j>S[i] && S.includes(j)){
          row.push(new RationalNumber(0, 1))}
        else {
          row.push(generateRationalNumber(den, 3))}
      }
      R.push(row)
    }
    return new RationalMatrix(R)
  }

  function generateAugmentedMatrix(rowNum, colNum, rank, isConsistent=true){
    if (isConsistent==true && rank>rowNum){
      throw new Error("Rank of matrix has to be at most the number of rows of the matrix for this case.")}
    else if (isConsistent==false && rank>=rowNum){
      throw new Error("Rank of matrix has to be less than the number of rows of the matrix for this case.")}
    else {
      // First, generate an (m x r)-matrix G of rank r 
      G = generateRationalFixedRankMatrix(rowNum, rank)
      // Then, generate an (r x (n-1))-matrix R of rank r in RREF 
      R = generateRationalRREF(colNum-1, rank)
      
      if (isConsistent == true){
        // Append some column vector to R to form M
        M = R.appendColumns([generateRationalTuple(rank)])

        // Now, we multiply G by M to make the matrix A
        // Permute the rows of A to obtain a matrix B
        A = G.multiply(M)
      }
      else {
        one = new RationalNumber(1, 1)
        zero = new RationalNumber(0, 1)

        // Now, we multiply G by R to make the matrix M
        M = G.multiply(R)

        // Search for a generic vector in Q^m that is not in 
        // the left nullspace of M
        // First, a vector with all distinct components is produced before it is rotated up to m times
        // The vector with the required property is guaranteed to be found because M 
        // is not of full rank but the span of the vector with its rotated versions span Q^m itself
        vector = []
        for (let k=0; k<rowNum; k++){    
          q = generateRationalNumber(4, 2)
          while (vector.includes(q)){
            q = generateRationalNumber(4, 2)}
          vector.push(q)
        }

        for (let i=0; i<rowNum; i++){
          if (!M.leftAnnihilates(vector)){
            A = M.appendColumns([vector])
            break
          }

          x = vector[0]
          vector = vector.slice(1, rowNum-1).push(x)
        }
      }
      
      p = generatePermutation(rowNum)
      B = []
      for (let i=0; i<rowNum; i++){
        j = p[i]
        B.push(A[j])
      }
      return new RationalMatrix(B)
    }
  }

  function generateRationalMatrix(rowNum, colNum){
    A = []
    for (let i=0; i<rowNum; i++){
      row = []
      den = generateInteger(1, 4)
      for (let j=0; j<colNum; j++){
        q = generateRationalNumber(den, 4)
        row.push(q)
      }
      A.push(row)
    }
    return new RationalMatrix(A)
  }
</script>

<script type="text/javascript">
  quests = [
    "1. Is this a consistent or an inconsistent system of linear equations?", // Can be consistent or incosistent
    "2. Which of these two types does this system of linear equations belong to?", // Can be consistent or inconsistent
    "3. Great, now, find a set of values for each variable that satisfies the following system of linear equation.", // Solution set need to exist
    "4. As a follow up, is there another set of solutions to the same system? If so, click on 'Multiple Solutions', otherwise, click on 'Unique Solution'.", // Can have unique or multiple solutions
    "5. Nice, can you find a set of values satisfying this system of linear equation?", // Solution set need to exist
    "6. Can there be another set of solutions to the same system?", // Can have unique or multiple solutions
    "7. Is there a nonzero vector that lies in the associated nullspace of this system? Click on 'None' if there is none.",
    "8. Does there exist one or many sets of solution to this system?",
    "9. Alright, is there a nonzero vector that lies in the associated nullspace of this system?",
    "10. Does there exist one or many sets of solution to this system?",
    "11. Let's switch gears. You are given a set of solutions to the following system. Can you use it to find another set of solutions?",
    "12. Good, given this set of solution, can you use it to find another set of solutions?",
    "Awesome!"
  ]
  initialized = 0
  page = 0

  function displayQuestion(page){
    // Handles the display of questions and question prompts
    landingArea = document.getElementById("questionToDisplay") 
    landingArea.innerHTML = quests[page]

    States = []
    if (page < 12){
      smallPages = [0, 2, 3, 6, 7, 10]
      if (smallPages.includes(page)){
        [numRows, numCols] = [3, 4]}
      else {
        [numRows, numCols] = [4, 5]}

      displayVariables()
      createAugmentedMatrix()

      if (page < 6){
        beingConsistent = true
        if (page == 0){
          rankValue = numRows-1}
        else if (page == 1){
          rankValue = numRows-1
          beingConsistent = false
        }
        else if (page == 2 || page == 4){
          rankValue = numRows}
        else if (page == 3 || page == 5){
          rankValue = numRows-1}
        A = generateAugmentedMatrix(numRows, numCols, rankValue, beingConsistent)
      }

      
      writeAugmentedMatrix(A)
    }
    else {
      A = generateAugmentedMatrix(6, 7, 5)
      writeAugmentedMatrix(A)}
    activateRows()
    equations()
    writeEquations()
  }
  
  function submitResponse(){
    if (initialized == 0){
      button = document.getElementById("submitButton")
      button.innerHTML = "Submit"
      initialized = 1
      displayQuestion(0)
    }
    else if (initialized == 1){
      //page += 1
      //displayQuestion(page)
    }
  }

  function gradeResponse(){
    
  }

  function createAugmentedMatrix(){    
    outer.value = [numRows, numCols]
    outer.style.height = 75*6+50+"px"
    outer.style.width = 75*numCols+90+"px"
    while (outer.firstChild){
      outer.removeChild(outer.lastChild)}

    // separator for augmented matrix
    separator = document.createElement('div')
    separator.className = 'separators'
    separator.style.left = 75*numCols+15+"px"
    separator.style.height = 75*numRows-20+"px"
    outer.appendChild(separator)

    // inputs
    for (let i=0; i<numRows; i++){
      input = document.createElement('input')
      input.className = 'scalarInputs'
      input.type = "text"
      input.name = i+1
      input.id = "in"+(i+1)      
      input.style.top = (75*i+45)+"px"
      outer.appendChild(input)
    }

    // switchbars
    for (let i=0; i<numRows-1; i++){
      switchbar = document.createElement('button')
      switchbar.className = 'switches'
      switchbar.style.width = numCols*75+"px"
      switchbar.style.top = (75*i+95)+"px"
      switchbar.id = "switch"+(i+1)+(i+2)
      switchbar.name = i
      switchbar.addEventListener("click", function() {switchAdjacentRows()}, false)
      outer.appendChild(switchbar)
    }

    // multipliers
    for (let i=0; i<numRows; i++){
      multiplier = document.createElement('button')
      multiplier.className = 'multiplyButtons'
      multiplier.style.top = (75*i+45)+"px"
      multiplier.id = "mult"+(i+1)
      multiplier.name = i+1
      multiplier.innerHTML = "&times"
      multiplier.addEventListener("click", function() {multiplyByScalar()}, false)
      outer.appendChild(multiplier)
    }

    // rows
    var Colors = colorList
    for (let i=0; i<numRows; i++){
      row = document.createElement('div')
      row.className = 'matrixRows'
      row.style.width = (numCols*75)+"px"
      row.style.top = (75*i+40)+"px"
      row.style.backgroundColor = Colors[i]
      row.id = Colors[i]+"tip"
      outer.appendChild(row)

      for (let j=0; j<numCols; j++){
        col = document.createElement('div')
        col.className = 'matrixColumns center'
        col.style.left=(75*j)+"px"
        col.id = colorList[i]+(j+1)
        row.appendChild(col)
      }
    }
  }

  function displayVariables(){
    boxes = document.getElementById("variables")
    while (boxes.firstChild){
      boxes.removeChild(boxes.lastChild)}

    for (let i=0; i<numCols-1; i++){
      variable = document.createElement('button')
      variable.className = 'variables'

      variable.style.left = (75*i+110)+"px"
      variable.id = variables[i]
      variable.name = variables[i]
      variable.innerHTML = variables[i]

      boxes.appendChild(variable)
    }

    for (let i=0; i<numCols-1; i++){
      solution = document.createElement('input')
      solution.className = 'solutionSet'

      solution.type = 'text'
      solution.style.left = (75*i+110)+"px"
      solution.id = variables[i]+'-val'

      boxes.appendChild(solution)
    }
  }

  function writeAugmentedMatrix(matrixA){
    if (numRows!=matrixA.length || numCols!=matrixA[0].length){
      throw "Matrix should have the correct dimensions"}

    for (let i=0; i<numRows; i++){
      for (let j=0; j<numCols; j++){
        address = document.getElementById(colorList[i]+(j+1))
        address.textContent = matrixA[i][j].toString()
      }
    }
  }

  // This function retrieves entries of the augmented matrix
  function readAugmentedMatrix(){
    A = []
    for (let i=0; i<numRows; i++){
      row = []
      for (var j=0; j<numCols; j++){
        address = document.getElementById(colorList[i]+(j+1)) 
        row.push(parseRational(address.textContent))
      }
      A.push(row)
    }
    return new RationalMatrix(A)
  }

  function writeEquations(){
    Entries = readAugmentedMatrix()

    Colors = []
    for (let i=0; i<numRows; i++){
      colortip = document.getElementById(colorList[i]+"tip")
      Colors.push(colortip.style.backgroundColor)
    }

    equationElement = document.getElementById("equations")
    equationList = []

    for (let i=0; i<numRows; i++){
      eq = ''
      for (let j=0; j<numCols-1; j++){
        q = Entries[i][j].toString()
        if (q == '1'){
          eq += '+'+variables[j]}
        else if (q == '-1'){
          eq += '-'+variables[j]}
        else if (q != '0'){
          if (q[0]=='-'){
            eq += q+variables[j]}
          else {
            eq += '+'+q+variables[j]}
        }
      }
      eq += '='+Entries[i][numCols-1].toString()
      if (eq[0]=='+'){
        eq = ' '+eq.substring(1,eq.length)}
      if (eq[0]=='='){
        eq = '0'+eq}

      equationList.push(eq)
    }

    while(equationElement.firstChild){
      equationElement.removeChild(equationElement.firstChild)
    }
    for (let i=0; i<numRows; i++){
      newEquation = document.createElement('div')
      newEquation.className = 'equationElement'
      newEquation.innerHTML = equationList[i]
      newEquation.style.top = 15+75*i+"px"
      newEquation.style.color = Colors[i]
      equationElement.appendChild(newEquation)
    }
  }

  function nextPage(){
    if (page<quests.length-1 && initialized==1){
      page += 1
      displayQuestion(page)
    }
  }

  function previousPage(){
    if (page>0 && initialized==1){
      page -= 1
      displayQuestion(page)
    }
  }

  function succeedAutomatically(){
    if (initialized != 1){
      return }
    if (page < quests.length){
      page += 1}
    displayQuestion(page)
  }

  function equations(){
    equationBox = document.getElementById("equations")
    equationBox.style.left = 75*numCols+150+"px"
    equationBox.style.height = 75*numRows-10+"px"
  }

  function multiplyByScalar(){
    let i = parseInt(document.activeElement.name)-1
    recordState()

    constant = document.getElementById("in"+(i+1))
    Row = readAugmentedMatrix()[i]
    scalar = parseRational(constant.value)

    zero = new RationalNumber(0,1)
    if (scalar.equals(zero)){
      alert("Given scalar cannot be zero.")
      return 
    }
    else {
      for (let j=0; j<numCols; j++){
        address = document.getElementById(colorList[i]+(j+1))
        q = scalar.multiply(Row[j])
        address.textContent = q.toString()
      }
    }

    constant.value = ''
    writeEquations()
  }

  function addOrSwap(first, second){
    start = -1
    end = -1
    shift = 40

    for (let i=0; i<numRows; i++){
      if (75*i+shift<first && first<75*i+50+shift){
        start=i}
      if (75*i+shift<second && second<75*i+50+shift){
        end=i}
    }

    if (start != end){
      recordState()
      Entries = readAugmentedMatrix()

      constant = document.getElementById("in"+(start+1))
      if (constant.value == ''){
        for (let j=0; j<numCols; j++){
          FirstAddress = document.getElementById(colorList[start]+(j+1))
          SecondAddress = document.getElementById(colorList[end]+(j+1))
          tempValue = FirstAddress.textContent
          FirstAddress.textContent = SecondAddress.textContent
          SecondAddress.textContent = tempValue
        }
        FirstTip = document.getElementById(colorList[start]+"tip")
        SecondTip = document.getElementById(colorList[end]+"tip")
        tempColor = FirstTip.style.backgroundColor
        FirstTip.style.backgroundColor = SecondTip.style.backgroundColor
        SecondTip.style.backgroundColor = tempColor
      }
      else if (constant.value != ''){
        C = parseRational(constant.value)

        startRow = Entries[start]
        endRow = Entries[end]

        for (let j=0; j<numCols; j++){
          FirstAddress = document.getElementById(colorList[start]+(j+1))
          SecondAddress = document.getElementById(colorList[end]+(j+1))
          x1 = parseRational(FirstAddress.textContent)
          x2 = parseRational(SecondAddress.textContent)
          SecondAddress.textContent = ((C.multiply(x1)).add(x2)).toString()
        }
        constant.value = ''
      }
      
      writeEquations()
    }
  }

  function initializePage(){
    displayVariables()
    createAugmentedMatrix()
    A = generateAugmentedMatrix(5, 6, 4)
    writeAugmentedMatrix(A)
    activateRows()
    equations()
    writeEquations()

    States = []
    
    score()
  }

  function activateRows(){
    for (let i=0; i<numRows; i++){
      input = document.getElementById("in"+(i+1))
      input.addEventListener("keydown", function (e){
        if (e.code === "Enter"){ 
          multiplyByScalar()}
      })
    }
    for (let i=0; i<numRows; i++){
      colortip = document.getElementById(colorList[i]+"tip")
      mobilize(colortip)
    }
  }

  // adds a performed operation into memory
  function recordState(){
    state = [readAugmentedMatrix()]

    COLORS = []
    for (let j=0; j<numRows; j++){
      colortip = document.getElementById(colorList[j]+"tip")
      COLORS.push(colortip.style.backgroundColor)
    }

    state.push(COLORS)
    States.push(state)
  }

  // removes the most recently performed operation from memory
  function revertState(){
    lastState = States[States.length-1]

    Entries = readAugmentedMatrix()
    for (let i=0; i<Entries.length; i++){
      for (let j=0; j<Entries[i].length; j++){
        Entries[i][j].textContent = lastState[0][i][j].toString()
      }
    }
    
    COL = []
    for (let j=0; j<numRows; j++){
      colortip = document.getElementById(colorList[j]+"tip")
      colortip.style.backgroundColor = lastState[1][j]
    } 
    States.splice(States.length-1, 1)
  }

  function switchAdjacentRows(){
    var i = 1 + parseFloat(document.activeElement.name)
    recordState()
    COL = []
    for (var j=0; j<numRows; j++){
      COL.push(document.getElementById(colorList[j]+"tip"))
    }
    FirstColor = COL[i-1].style.backgroundColor
    SecondColor = COL[i].style.backgroundColor
    
    var Entries = readAugmentedMatrix()
    First = Entries[i-1]
    Second = Entries[i]
    
    var FirstHTML = []
    var SecondHTML = []
    for (let j=0; j<numCols; j++){
      FirstHTML.push(First[j].innerHTML)
      SecondHTML.push(Second[j].innerHTML)
    }
    for (let j=0; j<numCols; j++){
      First[j].innerHTML = SecondHTML[j]
      Second[j].innerHTML = FirstHTML[j]
    }
    
    COL[i-1].style.backgroundColor = SecondColor
    COL[i].style.backgroundColor = FirstColor
    writeEquations()
  }

  function clear(){
    if (window.getSelection){
      window.getSelection().removeAllRanges()}
    else if (document.selection){
      document.selection.empty()}
  }

  function mobilize(tip){
    tip.onmousedown = move

    function move(e) {
      Y0 = e.clientY;
      x0 = e.clientX;
      y0 = e.clientY;
      document.onmousemove = drag;
      document.onmouseup = close;
    }

    function drag(e) {
      dx = e.clientX-x0;
      dy = e.clientY-y0;
      x0 = e.clientX;
      y0 = e.clientY;
      tip.style.left = (tip.offsetLeft + dx) + "px";
      tip.style.top = (tip.offsetTop + dy) + "px";
      clear()
    }
    
    function close(e) {
      shift = 40
      document.onmouseup = null;
      document.onmousemove = null;
      for (var v=0; v<numRows; v++){
        document.getElementById(colorList[v]+"tip").style.left = "100px";
        document.getElementById(colorList[v]+"tip").style.top = 75*v+shift+"px";
      }
      Y1 = e.clientY
      ABS = document.getElementById('outer').getBoundingClientRect()
      off = (ABS.top)
      addOrSwap(Y0-off,Y1-off)
     }  
  }

  const colorList = ["dodgerblue", "green", "tomato", "yellow", "orange", "sienna"]
  const variables = ['u', 'v', 'w', 'x', 'y', 'z']
  numRows = 5
  numCols = 6
  var Module_Number="14"
  questions = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  the_time = Date.now()
  make_grades(Module_Number)

  //page = 0

  initialMatrix = new RationalMatrix([
    [1, "1/5", "-2/5", 0, 0, 0, "3/5"], 
    [1, "1/3", "-2/3", 0, 0, 0, "-4/3"], 
    [0, 0, 0, 1, 0, 0, "1/4"], 
    [0, 0, 0, 0, 1, 0, "-1/2"], 
    [0, 0, 0, 0, 0, 1, 0], 
    [0, 0, 0, 0, 0, 0, "5/4"]
    ])
  //initializePage()

</script>
</body>
</html>