<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Linear Algebra: Complete Solution to the System Ax=b</title>

  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]},
    }
  </script>

  <!-- The following adds MathJax to render LaTeX notation -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>

  <link rel="stylesheet" href="../styles.css">

  <script src="../site-scripts.js"></script>

  <style type="text/css">
    #blank {
      position: relative;}

    .variables {
      position: absolute;
      background-color: white;
      font-size: 22px;
      top: 50px;
      width: 55px;
      height: 35px;}

    .solutionSet{
      position: absolute;
      background-color: lightyellow;
      top: 100px;
      width: 45px;
      height: 25px;}

    #outer {
      position: absolute;
      left: 0px;
      top: 210px;
      text-align: center;}

    #equations {
      position: absolute;
      height: 300px;
      width: 350px;
      left: 800px;
      top: 250px;
      background-color: black;
      text-align: center;}
    
    #line {
      position: absolute;
      height: 280px;
      width: 5px;
      left: 400px;
      top: 0px;
      background-color: black;}

    .center {
      text-align: center;
      font-size: 24px;}

    .separators {
      top: 40px;
      position: absolute;
      background-color: black;
      width: 10px;}

    .scalarInputs {
      position: absolute;
      background-color: lightyellow;
      left: 5px;
      font-size: 24px;
      width: 55px;
      height: 40px;}

    .switches {
      position: absolute;
      background-color: white;
      height: 20px;
      left: 100px;
    }

    .multiplyButtons {
      font-size: 24px;
      position: absolute;
      height: 46px;
      width: 28px;
      left: 70px;
      background-color: silver}

    .matrixRows {
      position: absolute;
      height: 50px;
      left: 100px;
      opacity: 0.8;}

    .matrixColumns {
      position: absolute;
      height: 45px;
      top: 10px;
      opacity: 0.8;
      background-color: #FFFFFF10;}

    #score {
      position: absolute;
      height: 220px;
      width: 90px;
      left: 1200px;
      top: 0px;
      background-color: white;
      text-align: center;}

    .systems {
      display: flex;
      justify-content: space-around;}

    .equationElement {
      position: absolute;
      width: 260px;
      height: 30px;
      font-size: 20px;
      left: 50px;}

    #completed {
      position: absolute;
      left: 10px;
      top: 650px
    }
  </style>
</head>

<body>
  <div style="position: absolute;">
    <a href="../linear-lab.html" class="backto">&#8592 Back to Linear Lab</a>
  </div>
  <div style="position: absolute; left:1099px;" class="backto" >
    <a href="../feedback.html">Provide Feedback &#8594</a>
  </div>
<h2><center>Module 14: Complete Solution to the System $Ax=b$</center></h2>

<div class="introduction">
  <p>
    Take a look at these three different systems of 3 linear equations:
    <ul class='systems'>
      <li> <b>System 1</b>
        $$\begin{aligned}
        x+y &= 1,\\
        y+z &= 2,\\
        x+z &= 3.\\ 
        \end{aligned}$$
      </li>
      <li> <b>System 2</b>
        $$\begin{aligned}
        x+y &= 1,\\
        y+z &= 2,\\
        x-z &= -1.\\ 
        \end{aligned}$$
      </li>
      <li> <b>System 3</b>
        $$\begin{aligned}
        x+y &= 1,\\
        y+z &= 2,\\
        x-z &= 3.\\ 
        \end{aligned}$$
      </li>
    </ul>
  </p>

  <p>
    In System 1, we can figure out the values of $x,y,z$ by first adding all three equations to produce $2x+2y+2z=6$, so that $x+y+z=3$. Subtracting each of the three equations from this one respectively gives $z=2, x=1, y=0$. This gives precisely the only set of solutions that solves System 1.
  </p>

  <p>
    Next, for System 2, we may infer the third equation by subtraction the first by the second, that is, 
    $$x-z = (x+y)-(y+z) = 1-2 =-1,$$
    This gives us some freedom to vary the value of $y$, so that the values of $x$ and $z$ can be inferred from the first two equations. 
    For example, we may have $y=0$ and thus that $x=1-y=1-0=1$ and $z=2-y=2-0=2$.
    If instead, we had chosen $y=1$, we would have $x=1-y=1-1=0$ and $z=2-y=2-1=1$.
    Both cases (and in fact, many more) are valid sets of solutions to this system.
  </p>

  <p>
    Finally, within System 3, we could similarly subtract the first equation by the second to obtain $x-z=-1$.
    However, this clearly contradicts the third equation, which says that $x-z=3$ as well.
    In this case, there are no values of $x$, $y$ and $z$ that satisfy all of these equations.
  </p>
  
  <p>
    Although these three systems are systems of 3 linear equations in 3 variables, their behaviors all differ:
    <ul>
      <li> One system yields a unique set of solutions,</li>
      <li> Another system yields more than one set of solutions,</li>
      <li> Yet another system cannot have a consistent set of solutions due to an inherent contradiction.</li>
    </ul>
  </p>
  
  <p>
    How do we distinguish these behaviors, you ask? For starters, consider the following framework. Suppose you have a system of $m$ linear equations in variables $x_1, x_2, x_3 \ldots, x_n$

    $$\begin{alignedat}{5}
      a_{1,1} x_1 & + a_{1,2} x_2 & + \ldots & + a_{1,n} x_n & = b_1,\\
      a_{2,1} x_1 & + a_{2,2} x_2 & + \ldots & + a_{2,n} x_n & = b_2,\\
      \vdots      &               &   \vdots &               & \\
      a_{m,1} x_1 & + a_{m,2} x_2 & + \ldots & + a_{m,n} x_n & = b_m,\\
    \end{alignedat}$$

    with real constants $a_{i,j}$ and $c_i$, where $1\leq i\leq m$, $1\leq j\leq n$.
    We may compress this as a matrix equation $Ax=b$ by setting 
    $$A = 
    \begin{bmatrix}
      a_{1,1} & a_{1,2} & \ldots & a_{1,n}\\
      a_{2,1} & a_{2,2} & \ldots & a_{2,n}\\
      \vdots  & \vdots  & \ddots & \vdots\\
      a_{m,1} & a_{m,2} & \ldots & a_{m,n}\\
    \end{bmatrix},\quad 
    x = \begin{bmatrix} x_1\\ x_2\\ \vdots\\ x_n \end{bmatrix},\quad 
    b = \begin{bmatrix} b_1\\ b_2\\ \vdots\\ b_m \end{bmatrix}.$$
    
    We may compute the r.r.e.f. of the augmented matrix $M=[A\;|\; b\;]$ to simplify our viewpoint of the same system. Based on the r.r.e.f. $M'$ of $M$, we could deduce three distinct behaviors:
    <ul>
      <li> 
        All columns of the left part of $M'$ contain a pivot. In this case, the values of each variable is unique and we may read off each of the values from the rows of $M'$.

        As an example, the augmented matrix associated to System 1 has its r.r.e.f. to be
      
        $$ M' = \begin{array}{c}
        \begin{array}{llll}
        \hspace{-5pt} x & y & z & \\
        \end{array}\\
        \left[\begin{array}{ccc|c}
        1 & 0 & 0 & 1\\
        0 & 1 & 0 & 0\\
        0 & 0 & 1 & 2\\
        \end{array}\right]\\
        \end{array},$$
        therefore, we have $(x,y,z)=(1,0,2)$.
        This system is said to be <b><em>consistent</em></b> as we have a solution set.
      </li>
      <li> 
        Not all columns on the left part of $M'$ contain a pivot; furthermore, whenever there is a row of zeros on the left part of $M'$, it is followed by a 0. In this case, each column containing a pivot corresponds to a <b><em>pivot variable</b></em> whereas each column that does not contain a pivot corresponds to a <b><em>free variable</b></em>. 

        For instance, the augmented matrix associated to System 2 has its r.r.e.f. to be
      
        $$ M' = \begin{array}{c}
        \begin{array}{llll}
        \hspace{-20pt} x & \hspace{-15pt} y & \hspace{-5pt} z & \\
        \end{array}\\
        \left[\begin{array}{ccc|c}
        1 & 0 & -1 & -1\\
        0 & 1 & 1 & 2\\
        0 & 0 & 0 & 0\\
        \end{array}\right]\\
        \end{array}.$$

        In this case, $x$ and $y$ are pivot variables, whereas $z$ is a free variable. 
        If we set $z=t$ for some real value $t$, we have $x=-1+z=-1+t$ and $y=2-z=2-t$, so that $(x,y,z)=(-1+t,2-t,t)$.

        In general, note that there are multiple valid sets of solutions that can be obtained by varying the values of each free variable. 
        Similar to the previous case, this system is said to be <b><em>consistent</em></b> as we also have at least one solution set.
      </li>
      <li> 
        Not all columns on the left part of $M'$ contain a pivot; furthermore, there is a row of zeros on the left part of $M'$ but is followed by a nonzero entry.

        In this case, there is no consistent set of values that can be assigned to each variable. We would have no solution here. 

        For instance, the augmented matrix associated to System 3 has its r.r.e.f. to be
      
        $$ M' = \begin{array}{c}
        \begin{array}{llll}
        \hspace{-15pt}x & \hspace{-10pt} y & z & \\
        \end{array}\\
        \left[\begin{array}{ccc|c}
        1 & 0 & -1 & 0\\
        0 & 1 & 1 & 0\\
        0 & 0 & 0 & 1\\
        \end{array}\right]\\
        \end{array}.$$
        Now, as the last row is a bunch of zeros followed by a 1, we cannot find a set of values for $x,y,z$ that satisfy the original system of equations.
        This system is said to be <b><em>inconsistent</em></b>.
      </li>
    </ul>
  </p>
</div>
  
<div class="instruction">
  <p>
    For this module, your task is to perform the following:
    <ul>
      <li>
        Determine whether or not a given system of equations is consistent.
      </li>
      <li>
        Determine the nature of the nullspace associated to a given system of equations.
      </li>
      <li>
        Find a set of solutions given another set of solutions when multiple solutions exist.
      </li>
    </ul>
    In all of the questions, please demonstrate your work by putting the matrix in r.r.e.f. (Refer to Module 11 in case you wish to review this.)
  </p>

  <p>
    You may perform row operations onto the matrix shown below:
    <ul>
      <li>
        To swap two rows, drag one of them and release it onto another; clicking on switchbars swaps two adjacent rows, 
      </li>
      <li>
        To scale a row, enter a rational number (of the form $a/b$) next to that row and click on the $\times$ symbol next to it,
      </li>
      <li>
        To add a multiple of one row to another, enter a rational number next to the row to be multiplied, then drag release it onto the target row.
      </li>
    </ul>
    The resulting system of equations is always shown on the screen to the right of the matrix. 
    Feel free to hit 'Undo' if you would like to backtrack some performed operations.
  </p>
</div>

<div id="blank">
  <div id="score">
  </div>

  <div>
    <h3>Current Question:</h3>

    <div id="questionToDisplay" style="height: 50px"></div>
    <div>
      <div id="multipleChoice" hidden>
        <input type="radio" id="answer1" name="multipleChoice" value="consistent">
        <label id="label1" for="answer1">Consistent System</label>
        <input type="radio" id="answer2" name="multipleChoice" value="inconsistent">
        <label id="label2" for="answer2">Inconsistent System</label>
      </div>
      
      <div class="feedbackArea" id="feedback"></div>
    </div>
    
    <button id="submitButton" onclick="submitResponse()"> Start </button>
    <button onclick="previousPage()"> Previous </button>
    <button onclick="nextPage()"> Next </button>
    <button onclick="revertState()"> Undo </button>
    <button id="none" onclick="submitResponse(impossibleAnswer=true)" hidden> None </button>
  </div>
  
  <div id="variables" style="position: absolute; top: 100px">
  </div>

  <div id="equations">
  </div>

  <!-- Displays augmented matrix gadget -->
  <div id="outer">
  </div>

  <div id="completed">
    <h2>Completed Questions:</h2>
  </div>
</div>

<script type="text/javascript">
  // Returns the gcd of two integers
  function gcd(a, b){
    if (a == 0 && b == 0){
      throw "Both integers cannot be both zero."
      return }
    if (a == 0){
      return Math.abs(b)}
    if (b == 0){
      return Math.abs(a)}
    if (b < 0){
      return gcd(a, -b)}
    if (a < 0){
      return gcd(-a, b)}
    return gcd(b, a%b)
  }

  // Defines a class of rational numbers
  class RationalNumber{
    constructor(a, b){
      if (b < 0){
        a = -a
        b = -b}
      let d = gcd(a,b)
      this.numerator = a/d
      this.denominator = b/d}

    toString(){
      if (this.denominator==1){
        return String(this.numerator)}
      return String(this.numerator)+"/"+String(this.denominator)}

    equals(that){
      return that instanceof RationalNumber && 
             this.numerator == that.numerator && 
             this.denominator == that.denominator
    }

    doesNotEqual(that){
      return !this.equals(that)}

    greaterThan(that){
      return this.numerator*that.denominator > this.denominator*that.numerator}

    greaterThanOrEquals(that){
      return this.numerator*that.denominator >= this.denominator*that.numerator}

    lessThan(that){
      return !this.greaterOrEquals(that)}

    lessThanOrEquals(that){
      return !this.greaterThan(that)}

    add(that){
      let m = this.numerator*that.denominator + this.denominator*that.numerator
      let n = this.denominator*that.denominator
      return new RationalNumber(m, n)}

    negate(){
      return new RationalNumber(-this.numerator, this.denominator)}

    subtract(that){
      return this.add(that.negate())}

    multiply(that){
      let m = this.numerator*that.numerator
      let n = this.denominator*that.denominator
      return new RationalNumber(m, n)}

    invert(){
      if (this.numerator==0){
        alert("One does not simply divide by zero.")}
      return new RationalNumber(this.denominator, this.numerator)}

    divide(that){
      return this.multiply(that.invert())}
  }

  function parseRational(input){
    // if input is already an instance of a rational number, do nothing
    if (input instanceof RationalNumber){
      return input}

    // if input is an integer, return is as a rational number
    if (!isNaN(input) && parseInt(input)==input){
      return new RationalNumber(input, 1)}

    n = input.length
    let numberExist = [false, false]
    let index = -1
    for (let i=0; i<n; i++){
      if (input[i] == '-'){
        if (i!=index+1 || i==n-1){
          throw new Error("This is not a rational number.")
          return 
        } 
      } 
      else if (input[i] == '/'){
        if (i==0 || i==n-1 || index>0){
          throw new Error("This is not a rational number.")
          return 
        }
        index = i
      }
      else if (isNaN(input[i])){
        throw new Error("This is not a rational number.")
        return 
      } 
      else {
        if (!numberExist[0] && index==-1){
          numberExist[0] = true} 
        else if (!numberExist[1] && index > 0){
            numberExist[1] = true} 
      }
    }

    if(index==-1){
      if (!numberExist[0]){
        throw new Error("This is not a rational number.")
        return }
      let a = parseInt(input)
      return new RationalNumber(a, 1)}

    if (!numberExist[0] || !numberExist[1]){
      throw new Error("This is not a rational number.")
      return }
    let a = parseInt(input.slice(0, index))
    let b = parseInt(input.slice(index+1, n))
    return new RationalNumber(a, b)
  }

  // Defines a class of rational-valued matrices
  class RationalMatrix extends Array{
    constructor(M){
      for (let i=1; i<M.length; i++){
        if (M[i].length != M[0].length){
          alert("Given array must be rectangular.")
          throw new Error("Given array must be rectangular.")
        }
      }

      let matrixM = []
      for (let i=0; i<M.length; i++){
        let row = []
        for (let j=0; j<M[0].length; j++){
          let entry = parseRational(M[i][j])
          if (entry == undefined){
            throw new Error("Entry is not a rational number.")
            return 
          }
          row.push(entry)
        }
        matrixM.push(row)
      }
      super(...matrixM)
      this.rowDim = matrixM.length
      this.colDim = matrixM[0].length
      }

    toString(){
      let string = "["
      for (let i=0; i<this.length; i++){
        string += "["
        for (let j=0; j<this[0].length; j++){
          string += this[i][j].toString()
          if (j < this[i].length-1){
            string += ", "
          }
        }
        string += "]"
        if (i < this.length-1){
          string += ", "}
      }
      string += "]"
      return string
    }

    LaTeX(){
      let string = "\\begin{bmatrix} \n"
      for (let i=0; i<this.rowDim; i++){
        for (let j=0; j<this.colDim; j++){
          string += String(this[i][j]) + " "
          if (j < this.colDim-1){
            string += "& "}
        } 
        if (i < this.rowDim-1){
          string += "\\\\\n"}
      }
      string += "\n\\end{bmatrix}"
      return string
    }

    equals(that){
      if (!that instanceof RationalMatrix){
        return false}
      if (this.rowDim != that.rowDim || this[0].colDim != that[0].colDim){
        return false}
      for (let i=0; i<this.rowDim; i++){
        for (let j=0; j<this.colDim; j++){
          if (this[i][j].doesNotEqual(that[i][j])){
            return false}
        }
      }
      return true
    }

    doesNotEqual(that){
      return !this.equals(that)}

    transpose(){
      let matrixM = []
      for (let j=0; j<this.colDim; j++){
        row = []
        for (let i=0; i<this.rowDim; i++){
          row.push(this[i][j])
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    add(that){
      let matrixM = []
      for (let i=0; i<this.rowDim; i++){
        row = []
        for (let j=0; j<this.colDim; j++){
          row.push(this[i][j].add(that[i][j]))
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    negate(){
      let matrixM = []
      for (let i=0; i<this.rowDim; i++){
        row = []
        for (let j=0; j<this.colDim; j++){
          row.push(this[i][j].negate())
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    subtract(that){
      return this.add(that.negate())}

    multiply(that){
      if (this.colDim != that.rowDim){
        throw new Error("Dimensions of matrices must agree.")
        return 
      }

      let matrixM = []
      for (let i=0; i<this.rowDim; i++){
        row = []
        for (let j=0; j<that.colDim; j++){
          let sum = parseRational("0")
          for (let k=0; k<this.colDim; k++){
            sum = sum.add(this[i][k].multiply(that[k][j]))}
          row.push(sum)
        }
        matrixM.push(row)
      }
      return new RationalMatrix(matrixM)
    }

    isNonZero(){
      for (let i=0; i<this.rowDim; i++){
        if (this.firstNonZero(i) < this.colDim){
          return true}
      }
      return false
    }

    annihilates(vector){
      if (vector.length != this.colDim){
        return false}

      let zero = new RationalNumber(0, 1)
      let o = []
      for (let i=0; i<this.rowDim; i++){
        o.push([zero])}
      let zeroVector = new RationalMatrix(o)

      return zeroVector.equals(this.multiply(vector))
    }

    leftAnnihilates(vector){
      if (vector.length != this.rowDim){
        return false}

      let zero = new RationalNumber(0, 1)
      let o = []
      for (let i=0; i<this.colDim; i++){
        o.push(zero)}
      let zeroVector = new RationalMatrix(o)

      return zeroVector.equals(vector.multiply(this))
    }

    swapRows(ithRow, jthRow){
      if (ithRow>=this.rowDim || jthRow>=this.rowDim){
        throw new Error("Row index out of reach.")
        return 
      }
      let matrixM = []
      for (let k=0; k<this.rowDim; k++){
        if (k!=ithRow && k!=jthRow){
          matrixM.push(this[k])}
        else {
          matrixM.push(this[ithRow+jthRow-k])}
      }
      return new RationalMatrix(matrixM)
    }

    scaleRows(ithRow, cScalar){
      if (ithRow >= this.rowDim){
        throw new Error("Row index out of reach.")
        return
      }
      let matrixM = []
      for (let k=0; k<this.rowDim; k++){
        if (k != ithRow){
          matrixM.push(this[k])}
        else {
          row = []
          for (let h=0; h<this.colDim; h++){
            row.push(this[k][h].multiply(parseRational(cScalar)))
          }
          matrixM.push(row)
        }
      }
      return new RationalMatrix(matrixM)
    }

    addRows(ithRow, jthRow, cScalar){
      if (ithRow>=this.rowDim || jthRow>=this.rowDim){
        throw new Error("Row index out of reach.")
        return
      }
      let matrixM = []
      for (let k=0; k<this.rowDim; k++){
        if (k != jthRow){
          matrixM.push(this[k])}
        else {
          row = []
          for (let h=0; h<this.colDim; h++){
            let entry = this[k][h].add(this[ithRow][h].multiply(parseRational(cScalar)))
            row.push(entry)
          }
          matrixM.push(row)
        }
      }
      return new RationalMatrix(matrixM)
    }

    // Return the index of the first nonzero entry of row i of the matrix
    firstNonZero(i){
      zero = new RationalNumber(0, 1)
      row = this[i]
      j = this.colDim
      for (let k=0; k<this.colDim; k++){
        if (row[k].doesNotEqual(zero)){
          j = k
          break
        }
      }
      return j
    }

    // Verifies that a rational matrix is in RREF
    isInRREF(){
      zero = new RationalNumber(0, 1)
      one = new RationalNumber(1, 1)
      // Checks that first nonzero entries of each row progresses from left to right
      let first = this.firstNonZero(0)
      let nonzeroRows = [first]

      for (let i=1; i<this.rowDim; i++){
        let second = this.firstNonZero(i)
        if (first > second){
          return false}
        first = second
        nonzeroRows.push(first)
      }
      
      // Checks that pivots are normalized to 1 
      // and that entries above and below pivots are 0s.
      for (let i=0; i<nonzeroRows.length; i++){
        first = nonzeroRows[i]
        if (first >= this.colDim){
          break}
        for (let k=0; k<this.rowDim; k++){
          let entry = this[k][first]
          if (k == i){
            if (entry.doesNotEqual(one)){
              return false}
          }
          else {
            if (entry.doesNotEqual(zero)){
              return false}
          }
        }
      }
      return true
    }

    limitColumns(start, end){
      let n = this.colDim
      if (start > end){
        throw new Error("Starting index must be no greater than ending index.")
        return
      }
      if (start > n || end < 0){
        throw new Error("Column indices should range between 0 and " + n-1 + ".")
        return
      }
      if (end > n-1){
        return this.limitColumns(start, n-1)}
      if (start < 0){
        return this.limitColumns(0, end)}
      let M = []
      for (let i=0; i<this.rowDim; i++){
        M.push(this[i].slice(start, end+1))}
      return new RationalMatrix(M)
    }

    appendColumns(columns){
      for (let j=0; j<columns.length; j++){
        if (columns[j].length != this.rowDim){
          throw new Error("The number of rows for each column vector must match with the matrix.")
          return
        }
      }

      let A = []
      for (let i=0; i<this.rowDim; i++){
        row = this[i]
        for (let j=0; j<columns.length; j++){
          row.push(columns[j][i])}
        A.push(row)
      }
      return new RationalMatrix(A)
    }
  }

  // This class structures a string as a response string that can be compared with other objects 
  class ResponseString{
    constructor(string){
      this.response = string}

    toString(){
      return String(this.response)}

    equals(that){
      return that instanceof ResponseString && this.response == that.response}

    doesNotEqual(that){
      return !this.equals(that)}
  }
</script>

<script type="text/javascript">
  // Random generation of mathematical objects

  // Returns an integer in the interval [low, high]
  function generateInteger(low, high){
    difference = high - low + 1
    return low + Math.floor(difference * Math.random())
  }

  // Return a permutation of the set {0,1,2,...,n-1}
  function generatePermutation(n){
    array = []
    for (let i=0; i<n; i++){
      array.push(i)
    }

    for (let i=0; i<n-1; i++){
      j = i + generateInteger(0, n-1-i)
      temp = array[i]
      array[i] = array[j]
      array[j] = temp
    }
    return array
  }

  // Return a subset of size k of the set {0,1,2,...,n-1}
  function generateSubset(k, n){
    array = []
    for (let i=0; i<n; i++){
      array.push(i)
    }

    for (let i=0; i<k-1; i++){
      j = i + generateInteger(0, n-1-i)
      temp = array[i]
      array[i] = array[j]
      array[j] = temp
    }
    S = array.splice(0, k)
    return S.sort()
  }

  function generateRationalNumber(den, maxRange, allowZero=true){
    maxNum = maxRange * den

    if (allowZero){
      num = generateInteger(-maxNum, maxNum)
      return new RationalNumber(num, den)
    }

    sign = (-1)**generateInteger(0, 1)
    unsignedNum = generateInteger(1, maxNum)
    return new RationalNumber(sign*unsignedNum, den)
  }

  function generateRationalTuple(rank){
    scalars = []
    Dist = [1,1,1,1,2,2,2,2,3,3,3,4,4,5]
    q = generateInteger(0, Dist.length-1)
    den = Dist[q]
    for (let i=0; i<rank; i++){
      scalars.push(generateRationalNumber(den, 2))
    }
    return scalars
  }

  ////////////////////////////////////////////
  // Generation of rational-valued matrices //
  ////////////////////////////////////////////
  function generateRREFMatrix(rowNum, colNum, rank) {
    m = Math.min(rowNum, colNum)
    if (m < rank){
      throw new Error("Rank should be not exceed both number of rows and number of columns.")}

    S = generateSubset(rank, colNum)
    zero = new RationalNumber(0, 1)
    one = new RationalNumber(1, 1)

    R = []
    Dist = [1,1,1,1,2,2,2,2,3,3,3,4,4,5]
    for (let i=0; i<rowNum; i++){
      row = []
      q = generateInteger(0, Dist.length-1)
      den = Dist[q]
      for (let j=0; j<colNum; j++){
        if (i < S.length){
          if (S[i]==j){
            row.push(one)}
          else if (j<S[i] || S.includes(j)){
            row.push(zero)}
          else {
            row.push(generateRationalNumber(den, 2))}
        }
        else {
          row.push(zero)
        }
      }
      R.push(row)
    }
    return new RationalMatrix(R)
  }

  function generateScalingMatrix(rowNum){
    zero = new RationalNumber(0, 1)
    K = []
    for (let i=0; i<rowNum; i++){
      row = []
      for (let j=0; j<rowNum; j++){
        if (i==j){
          m = generateRationalNumber(1, 3, allowZero=false)
          row.push(m)
        }
        else {
          row.push(zero)}
      }
      K.push(row)
    }
    return new RationalMatrix(K)
  }

  function generateRowAdditionMatrix(rowNum, maxDepth=5){
    zero = new RationalNumber(0, 1)
    one = new RationalNumber(1, 1)

    M = []
    for (let i=0; i<rowNum; i++){
      row = []
      for (let j=0; j<rowNum; j++){
        if (i == j){
          row.push(one)
        }
        else {
          row.push(zero)
        }
      }
      M.push(row)
    }
    A = new RationalMatrix(M)
    if (rowNum == 1){
      return A}

    for (let k=0; k<maxDepth; k++){
      perm = generatePermutation(rowNum)
      i = perm[0]
      j = perm[1]
      c = (-1)**generateInteger(1, 10)
      A = A.addRows(i, j, c)
    }

    return A
  }

  function appendConsistentColumn(matrixR){
    column = []
    zero = new RationalNumber(0, 1)
    Dist = [1,1,1,1,2,2,2,2,3,3,3,4,4,5]
    for (let i=0; i<matrixR.rowDim; i++){
      if (matrixR.firstNonZero(i)==matrixR.colDim){
        column.push(zero)}
      else {
        q = generateInteger(0, Dist.length-1)
        den = Dist[q]
        column.push(generateRationalNumber(den, 2))}
    }
    return matrixR.appendColumns([column])
  }

  function makeAugmentedMatrix(rowNum, colNum, rank, isConsistent=true){
    if (rank>rowNum){
      throw new Error("Rank of matrix has to be at most the number of rows of the matrix for this case.")}
    else {
      matrixR = generateRREFMatrix(rowNum, colNum-1, rank)
      matrixC = generateScalingMatrix(rowNum)
      matrixA = generateRowAdditionMatrix(rowNum, maxDepth=5)

      if (isConsistent==true){
        matrixP = appendConsistentColumn(matrixR)
      }
      else { 
        // Create a generic vector in Q^m that is not in the range of R.
        // The vector with the required property is guaranteed to be found 
        // because R is in RREF and is not of full rank but the final component of the vector is nonzero.
        vect = []
        Dist = [1,1,1,1,2,2,2,2,3,3,3,4,4,5]
        for (let i=0; i<rowNum; i++){
          den = Dist[q]
          q = generateInteger(0, Dist.length-1)
            den = Dist[q]
          if (i<rank){
            Q = generateRationalNumber(den, 2)}
          else {
            Q = generateRationalNumber(den, 2, allowZero=false)}
          vect.push(Q)
        }
        matrixP = matrixR.appendColumns([vect])
      }

      matrixM = (matrixA.multiply(matrixC)).multiply(matrixP)
      p = generatePermutation(rowNum)
      B = []
      for (let i=0; i<rowNum; i++){
        j = p[i]
        B.push(matrixM[j])
      }
      return new RationalMatrix(B)
    }
  }
</script>

<script type="text/javascript">
  quests = [
    "1. Is this a consistent or an inconsistent system of linear equations?", // Can be consistent or incosistent
    "2. Which of these two types does this system of linear equations belong to?", // Can be consistent or inconsistent
    "3. Nice, is this a consistent or an inconsistent system of linear equations?", // Can be consistent or incosistent
    "4. Which kind of a linear system of equations is this?", // Can be consistent or inconsistent
    "5. Great, now, find a set of values for each variable that satisfies the following system of linear equation.", // Solution set need to exist
    "6. As a follow up, is there another set of solutions to the same system? If so, give one such set and select 'Multiple Solutions', otherwise, select 'Unique Solution'.", // Can have unique or multiple solutions
    "7. Nice, can you find a set of values satisfying this system of linear equation?", // Solution set need to exist
    "8. Is there another set of solutions to the same system?", // Can have unique or multiple solutions
    "9. Is there a nonzero vector that lies in the associated nullspace of this system? Enter one such vector if there is one, otherwise, select 'None'.",
    "10. Does there exist one or many sets of solution to this system?",
    "11. Alright, is there a nonzero vector that lies in the associated nullspace of this system? If so, enter this vector and if not, select None.",
    "12. Does there exist one or many sets of solution to this system?",
    "Awesome!"
  ]
  initialized = 0
  page = 0

  function displayQuestion(pageNum){
    // Handles the display of questions and question prompts
    landingArea = document.getElementById("questionToDisplay") 
    landingArea.innerHTML = quests[pageNum]

    States = []
    recordState()
    if (pageNum < 12){
      var page_string = (pageNum+1).toString()
      params = parameter_dict[page_string]
      numRows = params[0]
      numCols = params[1]
      displayVariables()
      createAugmentedMatrix()
      A = matrix_list[pageNum]

      multipleChoiceArea = document.getElementById("multipleChoice")
      button = document.getElementById("none")

      multipleChoicePages = [0, 1, 2, 3, 5, 7, 9, 11]
      vectorInputPages = [4, 5, 6, 7, 8, 10]
      consistencyPages = [0, 1, 2, 3]
      inferencePages = [5, 7, 9, 11]
      nullspacePages = [8, 10]

      button.hidden = true
      if (multipleChoicePages.includes(pageNum)){
        multipleChoiceArea.hidden = false
        
        label1 = document.getElementById("label1")
        label2 = document.getElementById("label2")
        answer1 = document.getElementById("answer1")
        answer2 = document.getElementById("answer2")

        if (consistencyPages.includes(pageNum)){
          label1.textContent = "Consistent System"
          label2.textContent = "Inconsistent System"
          answer1.value = "consistent"
          answer2.value = "inconsistent"
        }
        else if (inferencePages.includes(pageNum)){
          label1.textContent = "Unique Solution"
          label2.textContent = "Multiple Solutions"
          answer1.value = "unique solution"
          answer2.value = "multiple solutions"
        }
      }
      else {
        multipleChoiceArea.hidden = true
        if (nullspacePages.includes(pageNum)){
            button.hidden = false}
      }
    }
    else {
      numRows = 6
      numCols = 7
      displayVariables()
      createAugmentedMatrix()
      A = makeAugmentedMatrix(6, 7, 4)

      multipleChoiceArea = document.getElementById("multipleChoice")
      multipleChoiceArea.hidden = true
    }
    writeAugmentedMatrix(A)
    activateRows()
    equations()
    writeEquations()
  }
  
  function submitResponse(impossibleAnswer=false){
    if (initialized == 0){
      button = document.getElementById("submitButton")
      button.innerHTML = "Submit"
      initialized = 1
      displayQuestion(0)
    }
    else if (initialized == 1){
      var correct = 0

      M = readAugmentedMatrix()
      matrixA = M.limitColumns(0, M.colDim-2)
      vector_b = M.limitColumns(M.colDim-1, M.colDim-1)

      if (!matrixA.isInRREF()){
        alert("The matrix is not yet in RREF.")
        return 
      }

      vectorInputPages = [4, 5, 6, 7, 8, 10, 12]
      uniquenessPages = [4, 6]
      uniquenessInferencePages = [5, 7]
      nullspacePages = [8, 10]

      // For Questions 5, 6, 7, 8, 9, 11
      // where a solution vector is expected
      if (vectorInputPages.includes(page)){
        // For Questions 9 and 11
        if (nullspacePages.includes(page)){
          pageString = (page+1).toString()
          rowValue = parameter_dict[pageString][0]
          rankValue = parameter_dict[pageString][2]

          // If the matrix for the system is of full rank, then 'None' should 
          // be the correct answer
          if (rowValue==rankValue && impossibleAnswer==true){
            correct = 1}
          // If the matrix for the system is not of full rank, then the matrix 
          // should annihilate the nonzero vector
          else if (rowValue>rankValue && impossibleAnswer==false){
            vector_x = readSolutionVector()
            if (matrixA.annihilates(vector_x) && vector_x.isNonZero()){
              correct = 1}
          }
        }
        // For Questions 6 and 8
        else if (uniquenessInferencePages.includes(page)){
          pageString = (page+1).toString()
          rowNumber = parameter_dict[pageString][0]
          rank = parameter_dict[pageString][2]

          // Collect user response from radio input
          expectedResponse = getExpectedResponse(parameter_dict, page)
          selectedResponse = document.querySelector('input[name="multipleChoice"]:checked')
          if (selectedResponse==null){
            alert("A choice needs to be selected.")
            return 
          }
          responseValue = selectedResponse.value
          userResponse = new ResponseString(responseValue)
          // If matrix is not of full rank, multiple solutions are possible
          if (rowNumber>rank){
            vector_x = readSolutionVector()
            if ((matrixA.multiply(vector_x)).equals(vector_b) && userResponse.equals(expectedResponse)){
              correct = 1}
          }
          // If matrix is of full rank, unique solution is forced
          else {
            if (userResponse.equals(expectedResponse)){
              correct = 1}
          }
        }
        // For Questions 5 and 7
        else {
          vector_x = readSolutionVector()
          if ((matrixA.multiply(vector_x)).equals(vector_b)){
            correct = 1}
          if (page==12 && correct==1){
            alert("Fantastic, you have unlocked a secret for this module! Try to find another solution.")
          }
        }
      }
      // For Questions 1, 2, 3, 4, 10, 12
      else {
        // Collect user response from radio input
        expectedResponse = getExpectedResponse(parameter_dict, page)
        selectedResponse = document.querySelector('input[name="multipleChoice"]:checked')
        if (selectedResponse==null){
          alert("A choice needs to be selected.")
          return 
        }
        responseValue = selectedResponse.value
        userResponse = new ResponseString(responseValue)
        if (userResponse.equals(expectedResponse)){
          correct = 1}
        }

      feedbackArea = document.getElementById("feedback")
      if (correct == 1){
        feedbackArea.textContent = ""
        alert("Awesome, your answer is correct!")

        var answeredQuestion = document.createElement('div')
        answeredQuestion.innerHTML = quests[page]
        answeredQuestion.style.color="grey"
        var completedQuestions = document.getElementById("completed")
        completedQuestions.appendChild(answeredQuestion)
        grades[page][1] += 1
        
        if (page < 12){
          page += 1
          displayQuestion(page)  
        }
      }
      else {
        feedbackArea.textContent = "Try again"
        alert("Sorry, that was incorrect.")
        grades[page][0] += 1
        }
      sql_record(Module_Number)
    }
  }

  function generateMatrixList(){   
    parameterDict = {}
    consistency = [false, true]

    q1 = generateInteger(0, 1)
    q2 = 1 - q1
    c1 = consistency[q1]
    c2 = consistency[q2]
    a1 = generateInteger(0, 1)
    r1 = c1==true ? a1 : 1
    r2 = c2==true ? a1 : 1

    A1 = makeAugmentedMatrix(3, 4, 3-r1, c1)
    parameterDict["1"] = [3, 4, 3-r1, c1]
    A2 = makeAugmentedMatrix(4, 5, 4-r2, c2)
    parameterDict["2"] = [4, 5, 4-r2, c2]

    q3 = generateInteger(0, 1)
    q4 = 1 - q3
    a3 = generateInteger(0, 1)
    c3 = consistency[q3]
    c4 = consistency[q4]
    r3 = c3==true ? a3 : 1
    r4 = c4==true ? a3 : 1

    A3 = makeAugmentedMatrix(3, 4, 3-r3, c3)
    parameterDict["3"] = [3, 4, 3-r3, c3]
    A4 = makeAugmentedMatrix(4, 5, 4-r4, c4)
    parameterDict["4"] = [4, 5, 4-r4, c4]

    q5 = generateInteger(0, 1)
    q7 = 1 - q5
    
    A5 = makeAugmentedMatrix(3, 4, 3-q5)
    parameterDict["5"] = [3, 4, 3-q5, true]
    A6 = A5
    parameterDict["6"] = parameterDict["5"]

    A7 = makeAugmentedMatrix(4, 5, 4-q7)
    parameterDict["7"] = [4, 5, 4-q7, true]
    A8 = A7
    parameterDict["8"] = parameterDict["7"]

    q9 = generateInteger(0, 1)
    q11 = 1 - q9

    A9 = makeAugmentedMatrix(3, 4, 3-q9)
    parameterDict["9"] = [3, 4, 3-q9, true]
    A10 = A9
    parameterDict["10"] = parameterDict["9"]
    
    A11 = makeAugmentedMatrix(4, 5, 4-q11)
    parameterDict["11"] = [4, 5, 4-q11, true]
    A12 = A11
    parameterDict["12"] = parameterDict["11"]

    matrixList = [
      A1, A2, A3, A4, A5, A6, 
      A7, A8, A9, A10, A11, A12
      ]

    return [matrixList, parameterDict]
  }

  function getExpectedResponse(parameterDict, page){
    consistencyPages = [0, 1, 2, 3]
    uniquenessInferencePages = [5, 7]
    nullspaceInferencePages = [9, 11]

    pageString = (page+1).toString()

    // For Questions 1, 2, 3, 4
    if (consistencyPages.includes(page)){
      cons = parameterDict[pageString][3]
      if (cons){
        return new ResponseString("consistent")}
      else {
        return new ResponseString("inconsistent")}
    }
    // For Questions 6, 8, 10, 12
    else if (uniquenessInferencePages.includes(page) || nullspaceInferencePages.includes(page)){
      rowNumber = parameterDict[pageString][0]
      rank = parameterDict[pageString][2]
      if (rowNumber != rank){
        return new ResponseString("multiple solutions")}
      else {
        return new ResponseString("unique solution")}
    }
    else {
      return new ResponseString("")
    }
  }

  function createAugmentedMatrix(width=70){    
    w = width
    outer.value = [numRows, numCols]
    outer.style.height = w*6+50+"px"
    outer.style.width = w*numCols+90+"px"
    while (outer.firstChild){
      outer.removeChild(outer.lastChild)}

    // separator for augmented matrix
    separator = document.createElement('div')
    separator.className = 'separators'
    separator.style.left = w*numCols+15+"px"
    separator.style.height = w*numRows-20+"px"
    outer.appendChild(separator)

    // inputs
    for (let i=0; i<numRows; i++){
      input = document.createElement('input')
      input.className = 'scalarInputs'
      input.type = "text"
      input.name = i+1
      input.id = "in"+(i+1)      
      input.style.top = (w*i+45)+"px"
      outer.appendChild(input)
    }

    // switchbars
    for (let i=0; i<numRows-1; i++){
      switchbar = document.createElement('button')
      switchbar.className = 'switches'
      switchbar.style.width = numCols*w+"px"
      switchbar.style.top = (w*i+90)+"px"
      switchbar.id = "switch"+(i+1)+(i+2)
      switchbar.name = i
      switchbar.addEventListener("click", function() {switchAdjacentRows()}, false)
      outer.appendChild(switchbar)
    }

    // multipliers
    for (let i=0; i<numRows; i++){
      multiplier = document.createElement('button')
      multiplier.className = 'multiplyButtons'
      multiplier.style.top = (w*i+45)+"px"
      multiplier.id = "mult"+(i+1)
      multiplier.name = i+1
      multiplier.innerHTML = "&times"
      multiplier.addEventListener("click", function() {multiplyByScalar()}, false)
      outer.appendChild(multiplier)
    }

    // rows
    var Colors = colorList
    for (let i=0; i<numRows; i++){
      row = document.createElement('div')
      row.className = 'matrixRows'
      row.style.width = (numCols*w)+"px"
      row.style.top = (w*i+40)+"px"
      row.style.backgroundColor = Colors[i]
      row.id = Colors[i]+"tip"
      outer.appendChild(row)

      for (let j=0; j<numCols; j++){
        col = document.createElement('div')
        col.className = 'matrixColumns center'
        col.style.width = w+"px"
        col.style.left=(w*j)+"px"
        col.id = colorList[i]+(j+1)
        row.appendChild(col)
      }
    }
  }

  function displayVariables(width=70){
    w = width
    boxes = document.getElementById("variables")
    while (boxes.firstChild){
      boxes.removeChild(boxes.lastChild)}

    for (let i=0; i<numCols-1; i++){
      variable = document.createElement('button')
      variable.className = 'variables'

      variable.style.left = (w*i+110)+"px"
      variable.id = variables[i]
      variable.name = variables[i]
      variable.innerHTML = variables[i]

      boxes.appendChild(variable)
    }

    vectorInputPages = [4, 5, 6, 7, 8, 10, 12]
    if (vectorInputPages.includes(page)){
      for (let i=0; i<numCols-1; i++){
        solution = document.createElement('input')
        solution.className = 'solutionSet'
        solution.name = variables[i]+'-val'
        solution.type = 'text'
        solution.style.left = (w*i+110)+"px"
        solution.id = variables[i]+'-val'

        boxes.appendChild(solution)
      }
    }
  }

  function writeAugmentedMatrix(matrixA){
    if (numRows!=matrixA.length || numCols!=matrixA[0].length){
      throw "Matrix should have the correct dimensions"}

    for (let i=0; i<numRows; i++){
      for (let j=0; j<numCols; j++){
        address = document.getElementById(colorList[i]+(j+1))
        address.textContent = matrixA[i][j].toString()
      }
    }
  }

  // This function retrieves entries of the augmented matrix
  function readAugmentedMatrix(){
    A = []
    for (let i=0; i<numRows; i++){
      row = []
      for (let j=0; j<numCols; j++){
        address = document.getElementById(colorList[i]+(j+1)) 
        row.push(parseRational(address.textContent))
      }
      A.push(row)
    }
    return new RationalMatrix(A)
  }

  function readSolutionVector(){
    x = []
    for (let j=0; j<numCols-1; j++){
      address = document.getElementById(variables[j]+"-val")
      if (!address.value){
        alert("Rational entries are expected for each variable.")
        return
      }
      x.push([address.value])
    }
    return new RationalMatrix(x)
  }

  function writeEquations(width=70){
    w = width
    Entries = readAugmentedMatrix()

    Colors = []
    for (let i=0; i<numRows; i++){
      colortip = document.getElementById(colorList[i]+"tip")
      Colors.push(colortip.style.backgroundColor)
    }

    equationElement = document.getElementById("equations")
    equationList = []

    for (let i=0; i<numRows; i++){
      eq = ''
      for (let j=0; j<numCols-1; j++){
        q = Entries[i][j].toString()
        if (q == '1'){
          eq += '+'+variables[j]}
        else if (q == '-1'){
          eq += '-'+variables[j]}
        else if (q != '0'){
          if (q[0]=='-'){
            eq += q+variables[j]}
          else {
            eq += '+'+q+variables[j]}
        }
      }
      eq += '='+Entries[i][numCols-1].toString()
      if (eq[0]=='+'){
        eq = ' '+eq.substring(1,eq.length)}
      if (eq[0]=='='){
        eq = '0'+eq}

      equationList.push(eq)
    }

    while(equationElement.firstChild){
      equationElement.removeChild(equationElement.firstChild)
    }
    for (let i=0; i<numRows; i++){
      newEquation = document.createElement('div')
      newEquation.className = 'equationElement'
      newEquation.innerHTML = equationList[i]
      newEquation.style.top = 15+w*i+"px"
      newEquation.style.color = Colors[i]
      equationElement.appendChild(newEquation)
    }
  }

  function nextPage(){
    if (page<quests.length-1 && initialized==1){
      page += 1
      displayQuestion(page)
    }
  }

  function previousPage(){
    if (page>0 && initialized==1){
      page -= 1
      displayQuestion(page)
    }
  }

  function equations(width=70){
    w = width
    equationBox = document.getElementById("equations")
    equationBox.style.left = w*numCols+150+"px"
    equationBox.style.height = w*numRows-10+"px"
  }

  function multiplyByScalar(){
    let i = parseInt(document.activeElement.name)-1
    recordState()

    constant = document.getElementById("in"+(i+1))
    Row = readAugmentedMatrix()[i]
    scalar = parseRational(constant.value)

    zero = new RationalNumber(0,1)
    if (scalar.equals(zero)){
      alert("Given scalar cannot be zero.")
      return 
    }
    else {
      for (let j=0; j<numCols; j++){
        address = document.getElementById(colorList[i]+(j+1))
        q = scalar.multiply(Row[j])
        address.textContent = q.toString()
      }
    }

    constant.value = ''
    writeEquations()
  }

  function addOrSwap(first, second, width=70){
    w = width
    start = -1
    end = -1
    shift = 40

    for (let i=0; i<numRows; i++){
      if (w*i+shift<first && first<w*i+50+shift){
        start=i}
      if (w*i+shift<second && second<w*i+50+shift){
        end=i}
    }

    if (start != end){
      recordState()
      Entries = readAugmentedMatrix()

      constant = document.getElementById("in"+(start+1))
      if (constant.value == ''){
        for (let j=0; j<numCols; j++){
          FirstAddress = document.getElementById(colorList[start]+(j+1))
          SecondAddress = document.getElementById(colorList[end]+(j+1))
          tempValue = FirstAddress.textContent
          FirstAddress.textContent = SecondAddress.textContent
          SecondAddress.textContent = tempValue
        }
        FirstTip = document.getElementById(colorList[start]+"tip")
        SecondTip = document.getElementById(colorList[end]+"tip")
        tempColor = FirstTip.style.backgroundColor
        FirstTip.style.backgroundColor = SecondTip.style.backgroundColor
        SecondTip.style.backgroundColor = tempColor
      }
      else if (constant.value != ''){
        C = parseRational(constant.value)

        startRow = Entries[start]
        endRow = Entries[end]

        for (let j=0; j<numCols; j++){
          FirstAddress = document.getElementById(colorList[start]+(j+1))
          SecondAddress = document.getElementById(colorList[end]+(j+1))
          x1 = parseRational(FirstAddress.textContent)
          x2 = parseRational(SecondAddress.textContent)
          SecondAddress.textContent = ((C.multiply(x1)).add(x2)).toString()
        }
        constant.value = ''
      }
      
      writeEquations()
    }
  }

  function initializePage(){
    numRows = 5
    numCols = 6
    displayVariables()
    createAugmentedMatrix()
    A = makeAugmentedMatrix(5, 6, 4)
    writeAugmentedMatrix(A)
    pair = generateMatrixList()
    matrix_list = pair[0]
    parameter_dict = pair[1]
    activateRows()
    equations()
    writeEquations()

    States = []
    recordState()
    score()
  }

  function activateRows(){
    for (let i=0; i<numRows; i++){
      input = document.getElementById("in"+(i+1))
      input.addEventListener("keydown", function (e){
        if (e.code === "Enter"){ 
          multiplyByScalar()}
      })
    }
    for (let i=0; i<numRows; i++){
      colortip = document.getElementById(colorList[i]+"tip")
      mobilize(colortip)
    }
  }

  // adds a performed operation into memory
  function recordState(){
    state = [readAugmentedMatrix()]

    COLORS = []
    for (let j=0; j<numRows; j++){
      colortip = document.getElementById(colorList[j]+"tip")
      COLORS.push(colortip.style.backgroundColor)
    }

    state.push(COLORS)
    States.push(state)
  }

  // Removes the most recently performed operation from memory
  function revertState(){
    if (States.length == 1){
      alert("There are no operations to undo!")
      return
    }

    lastState = States[States.length-1]
    writeAugmentedMatrix(lastState[0])
    
    COL = []
    for (let j=0; j<numRows; j++){
      colortip = document.getElementById(colorList[j]+"tip")
      colortip.style.backgroundColor = lastState[1][j]
    } 
    States.splice(States.length-1, 1)
    writeEquations()
  }

  function switchAdjacentRows(){
    var i = 1 + parseFloat(document.activeElement.name)
    recordState()
    COL = []
    for (var j=0; j<numRows; j++){
      COL.push(document.getElementById(colorList[j]+"tip"))
    }
    FirstColor = COL[i-1].style.backgroundColor
    SecondColor = COL[i].style.backgroundColor
    
    COL[i-1].style.backgroundColor = SecondColor
    COL[i].style.backgroundColor = FirstColor

    A = readAugmentedMatrix()
    A = A.swapRows(i-1, i)
    writeAugmentedMatrix(A)

    writeEquations()
  }

  function clear(){
    if (window.getSelection){
      window.getSelection().removeAllRanges()}
    else if (document.selection){
      document.selection.empty()}
  }

  function mobilize(tip, width=70){
    w = width
    tip.onmousedown = move

    function move(e) {
      Y0 = e.clientY;
      x0 = e.clientX;
      y0 = e.clientY;
      document.onmousemove = drag;
      document.onmouseup = close;
    }

    function drag(e) {
      dx = e.clientX-x0;
      dy = e.clientY-y0;
      x0 = e.clientX;
      y0 = e.clientY;
      tip.style.left = (tip.offsetLeft + dx) + "px";
      tip.style.top = (tip.offsetTop + dy) + "px";
      clear()
    }
    
    function close(e) {
      shift = 40
      document.onmouseup = null;
      document.onmousemove = null;
      for (var v=0; v<numRows; v++){
        document.getElementById(colorList[v]+"tip").style.left = "100px";
        document.getElementById(colorList[v]+"tip").style.top = w*v+shift+"px";
      }
      Y1 = e.clientY
      ABS = document.getElementById('outer').getBoundingClientRect()
      off = (ABS.top)
      addOrSwap(Y0-off,Y1-off)
     }  
  }

  const colorList = ["dodgerblue", "green", "tomato", "yellow", "orange", "sienna"]
  const variables = ['u', 'v', 'w', 'x', 'y', 'z']
  var numRows
  var numCols
  var Module_Number="14"
  questions = [
    0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 
    0, 0
    ]
  the_time = Date.now()
  make_grades(Module_Number)
  initializePage()
</script>
</body>
</html>